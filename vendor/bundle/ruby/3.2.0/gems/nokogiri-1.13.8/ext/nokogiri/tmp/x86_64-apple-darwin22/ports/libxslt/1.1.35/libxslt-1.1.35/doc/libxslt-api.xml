<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libxslt'>
  <files>
    <file name='attributes'>
     <summary>interface for the XSLT attribute handling</summary>
     <description>this module handles the specificities of attribute and attribute groups processing. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltResolveStylesheetAttributeSet' type='function'/>
     <exports symbol='xsltParseStylesheetAttributeSet' type='function'/>
     <exports symbol='xsltApplyAttributeSet' type='function'/>
     <exports symbol='xsltFreeAttributeSetsHashes' type='function'/>
    </file>
    <file name='documents'>
     <summary>interface for the document handling</summary>
     <description>implements document loading and cache (multiple document() reference for the same resources must be equal. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_LOAD_START' type='enum'/>
     <exports symbol='XSLT_LOAD_DOCUMENT' type='enum'/>
     <exports symbol='XSLT_LOAD_STYLESHEET' type='enum'/>
     <exports symbol='xsltLoadType' type='typedef'/>
     <exports symbol='xsltDocDefaultLoader' type='variable'/>
     <exports symbol='xsltFreeStyleDocuments' type='function'/>
     <exports symbol='xsltDocLoaderFunc' type='function'/>
     <exports symbol='xsltLoadDocument' type='function'/>
     <exports symbol='xsltNewStyleDocument' type='function'/>
     <exports symbol='xsltSetLoaderFunc' type='function'/>
     <exports symbol='xsltFreeDocuments' type='function'/>
     <exports symbol='xsltNewDocument' type='function'/>
     <exports symbol='xsltLoadStyleDocument' type='function'/>
     <exports symbol='xsltFindDocument' type='function'/>
    </file>
    <file name='extensions'>
     <summary>interface for the extension support</summary>
     <description>This provide the API needed for simple and module extension support. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltRegisterExtFunction' type='function'/>
     <exports symbol='xsltRegisterExtModuleElement' type='function'/>
     <exports symbol='xsltInitCtxtExts' type='function'/>
     <exports symbol='xsltGetExtData' type='function'/>
     <exports symbol='xsltStyleGetExtData' type='function'/>
     <exports symbol='xsltStyleExtInitFunction' type='function'/>
     <exports symbol='xsltInitGlobals' type='function'/>
     <exports symbol='xsltShutdownExts' type='function'/>
     <exports symbol='xsltExtModuleElementPreComputeLookup' type='function'/>
     <exports symbol='xsltRegisterTestModule' type='function'/>
     <exports symbol='xsltStyleStylesheetLevelGetExtData' type='function'/>
     <exports symbol='xsltExtModuleElementLookup' type='function'/>
     <exports symbol='xsltStyleExtShutdownFunction' type='function'/>
     <exports symbol='xsltInitElemPreComp' type='function'/>
     <exports symbol='xsltDebugDumpExtensions' type='function'/>
     <exports symbol='xsltGetExtInfo' type='function'/>
     <exports symbol='xsltExtModuleTopLevelLookup' type='function'/>
     <exports symbol='xsltFreeExts' type='function'/>
     <exports symbol='xsltCheckExtURI' type='function'/>
     <exports symbol='xsltExtModuleFunctionLookup' type='function'/>
     <exports symbol='xsltPreComputeExtModuleElement' type='function'/>
     <exports symbol='xsltRegisterExtModuleTopLevel' type='function'/>
     <exports symbol='xsltPreComputeFunction' type='function'/>
     <exports symbol='xsltTopLevelFunction' type='function'/>
     <exports symbol='xsltShutdownCtxtExts' type='function'/>
     <exports symbol='xsltXPathGetTransformContext' type='function'/>
     <exports symbol='xsltRegisterExtElement' type='function'/>
     <exports symbol='xsltExtInitFunction' type='function'/>
     <exports symbol='xsltFreeCtxtExts' type='function'/>
     <exports symbol='xsltUnregisterExtModule' type='function'/>
     <exports symbol='xsltRegisterExtModuleFull' type='function'/>
     <exports symbol='xsltUnregisterExtModuleTopLevel' type='function'/>
     <exports symbol='xsltNewElemPreComp' type='function'/>
     <exports symbol='xsltUnregisterExtModuleElement' type='function'/>
     <exports symbol='xsltUnregisterExtModuleFunction' type='function'/>
     <exports symbol='xsltCheckExtPrefix' type='function'/>
     <exports symbol='xsltRegisterExtModule' type='function'/>
     <exports symbol='xsltExtElementLookup' type='function'/>
     <exports symbol='xsltRegisterExtModuleFunction' type='function'/>
     <exports symbol='xsltRegisterExtPrefix' type='function'/>
     <exports symbol='xsltExtShutdownFunction' type='function'/>
    </file>
    <file name='extra'>
     <summary>interface for the non-standard features</summary>
     <description>implement some extension outside the XSLT namespace but not EXSLT with is in a different library. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_XT_NAMESPACE' type='macro'/>
     <exports symbol='XSLT_XALAN_NAMESPACE' type='macro'/>
     <exports symbol='XSLT_SAXON_NAMESPACE' type='macro'/>
     <exports symbol='XSLT_LIBXSLT_NAMESPACE' type='macro'/>
     <exports symbol='xsltFunctionNodeSet' type='function'/>
     <exports symbol='xsltRegisterExtras' type='function'/>
     <exports symbol='xsltDebug' type='function'/>
     <exports symbol='xsltRegisterAllExtras' type='function'/>
    </file>
    <file name='functions'>
     <summary>interface for the XSLT functions not from XPath</summary>
     <description>a set of extra functions coming from XSLT but not in XPath </description>
     <author>Daniel Veillard and Bjorn Reese &lt;breese@users.sourceforge.net&gt; </author>
     <exports symbol='XSLT_REGISTER_FUNCTION_LOOKUP' type='macro'/>
     <exports symbol='xsltXPathFunctionLookup' type='function'/>
     <exports symbol='xsltFunctionAvailableFunction' type='function'/>
     <exports symbol='xsltFormatNumberFunction' type='function'/>
     <exports symbol='xsltRegisterAllFunctions' type='function'/>
     <exports symbol='xsltKeyFunction' type='function'/>
     <exports symbol='xsltUnparsedEntityURIFunction' type='function'/>
     <exports symbol='xsltDocumentFunction' type='function'/>
     <exports symbol='xsltSystemPropertyFunction' type='function'/>
     <exports symbol='xsltElementAvailableFunction' type='function'/>
     <exports symbol='xsltGenerateIdFunction' type='function'/>
    </file>
    <file name='imports'>
     <summary>interface for the XSLT import support</summary>
     <description>macros and fuctions needed to implement and access the import tree </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_GET_IMPORT_PTR' type='macro'/>
     <exports symbol='XSLT_GET_IMPORT_INT' type='macro'/>
     <exports symbol='xsltFindTemplate' type='function'/>
     <exports symbol='xsltNextImport' type='function'/>
     <exports symbol='xsltParseStylesheetInclude' type='function'/>
     <exports symbol='xsltNeedElemSpaceHandling' type='function'/>
     <exports symbol='xsltFindElemSpaceHandling' type='function'/>
     <exports symbol='xsltParseStylesheetImport' type='function'/>
    </file>
    <file name='keys'>
     <summary>interface for the key matching used in key() and template matches.</summary>
     <description>implementation of the key mechanims. </description>
     <author>Daniel Veillard </author>
     <exports symbol='NODE_IS_KEYED' type='macro'/>
     <exports symbol='xsltInitCtxtKeys' type='function'/>
     <exports symbol='xsltFreeKeys' type='function'/>
     <exports symbol='xsltGetKey' type='function'/>
     <exports symbol='xsltFreeDocumentKeys' type='function'/>
     <exports symbol='xsltAddKey' type='function'/>
    </file>
    <file name='namespaces'>
     <summary>interface for the XSLT namespace handling</summary>
     <description>set of function easing the processing and generation of namespace nodes in XSLT. </description>
     <author>Daniel Veillard </author>
     <exports symbol='UNDEFINED_DEFAULT_NS' type='macro'/>
     <exports symbol='xsltFreeNamespaceAliasHashes' type='function'/>
     <exports symbol='xsltCopyNamespace' type='function'/>
     <exports symbol='xsltCopyNamespaceList' type='function'/>
     <exports symbol='xsltGetNamespace' type='function'/>
     <exports symbol='xsltGetPlainNamespace' type='function'/>
     <exports symbol='xsltGetSpecialNamespace' type='function'/>
     <exports symbol='xsltNamespaceAlias' type='function'/>
    </file>
    <file name='numbersInternals'>
     <summary>Implementation of the XSLT number functions</summary>
     <description>Implementation of the XSLT number functions </description>
     <author>Bjorn Reese &lt;breese@users.sourceforge.net&gt; and Daniel Veillard </author>
     <exports symbol='xsltFormatNumberInfo' type='typedef'/>
     <exports symbol='xsltNumberData' type='typedef'/>
     <exports symbol='xsltNumberDataPtr' type='typedef'/>
     <exports symbol='xsltFormatNumberInfoPtr' type='typedef'/>
     <exports symbol='_xsltNumberData' type='struct'/>
     <exports symbol='_xsltCompMatch' type='struct'/>
     <exports symbol='_xsltFormatNumberInfo' type='struct'/>
    </file>
    <file name='pattern'>
     <summary>interface for the pattern matching used in template matches.</summary>
     <description>the implementation of the lookup of the right template for a given node must be really fast in order to keep decent performances. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltCompMatch' type='typedef'/>
     <exports symbol='xsltCompMatchPtr' type='typedef'/>
     <exports symbol='xsltNormalizeCompSteps' type='function'/>
     <exports symbol='xsltAddTemplate' type='function'/>
     <exports symbol='xsltCompilePattern' type='function'/>
     <exports symbol='xsltMatchPattern' type='function'/>
     <exports symbol='xsltGetTemplate' type='function'/>
     <exports symbol='xsltCompMatchClearCache' type='function'/>
     <exports symbol='xsltTestCompMatchList' type='function'/>
     <exports symbol='xsltFreeCompMatchList' type='function'/>
     <exports symbol='xsltFreeTemplateHashes' type='function'/>
     <exports symbol='xsltCleanupTemplates' type='function'/>
    </file>
    <file name='preproc'>
     <summary>precomputing stylesheets</summary>
     <description>this is the compilation phase, where most of the stylesheet is &quot;compiled&quot; into faster to use data. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltExtMarker' type='variable'/>
     <exports symbol='xsltFreeStylePreComps' type='function'/>
     <exports symbol='xsltDocumentComp' type='function'/>
     <exports symbol='xsltStylePreCompute' type='function'/>
    </file>
    <file name='security'>
     <summary>interface for the libxslt security framework</summary>
     <description>the libxslt security framework allow to restrict the access to new resources (file or URL) from the stylesheet at runtime. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_SECPREF_CREATE_DIRECTORY' type='enum'/>
     <exports symbol='XSLT_SECPREF_WRITE_FILE' type='enum'/>
     <exports symbol='XSLT_SECPREF_READ_NETWORK' type='enum'/>
     <exports symbol='XSLT_SECPREF_READ_FILE' type='enum'/>
     <exports symbol='XSLT_SECPREF_WRITE_NETWORK' type='enum'/>
     <exports symbol='xsltSecurityPrefs' type='typedef'/>
     <exports symbol='xsltSecurityPrefsPtr' type='typedef'/>
     <exports symbol='xsltSecurityOption' type='typedef'/>
     <exports symbol='xsltNewSecurityPrefs' type='function'/>
     <exports symbol='xsltSecurityCheck' type='function'/>
     <exports symbol='xsltSetSecurityPrefs' type='function'/>
     <exports symbol='xsltGetDefaultSecurityPrefs' type='function'/>
     <exports symbol='xsltFreeSecurityPrefs' type='function'/>
     <exports symbol='xsltSetDefaultSecurityPrefs' type='function'/>
     <exports symbol='xsltSetCtxtSecurityPrefs' type='function'/>
     <exports symbol='xsltGetSecurityPrefs' type='function'/>
     <exports symbol='xsltSecurityAllow' type='function'/>
     <exports symbol='xsltCheckWrite' type='function'/>
     <exports symbol='xsltCheckRead' type='function'/>
     <exports symbol='xsltSecurityForbid' type='function'/>
    </file>
    <file name='templates'>
     <summary>interface for the template processing</summary>
     <description>This set of routine encapsulates XPath calls and Attribute Value Templates evaluation. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltEvalStaticAttrValueTemplate' type='function'/>
     <exports symbol='xsltAttrListTemplateProcess' type='function'/>
     <exports symbol='xsltEvalTemplateString' type='function'/>
     <exports symbol='xsltAttrTemplateValueProcess' type='function'/>
     <exports symbol='xsltAttrTemplateProcess' type='function'/>
     <exports symbol='xsltEvalAttrValueTemplate' type='function'/>
     <exports symbol='xsltEvalXPathPredicate' type='function'/>
     <exports symbol='xsltAttrTemplateValueProcessNode' type='function'/>
     <exports symbol='xsltTemplateProcess' type='function'/>
     <exports symbol='xsltEvalXPathStringNs' type='function'/>
     <exports symbol='xsltEvalXPathString' type='function'/>
    </file>
    <file name='transform'>
     <summary>the XSLT engine transformation part.</summary>
     <description>This module implements the bulk of the actual</description>
     <author>Daniel Veillard </author>
     <exports symbol='xsltValueOf' type='function'/>
     <exports symbol='xsltRegisterAllElement' type='function'/>
     <exports symbol='xsltSort' type='function'/>
     <exports symbol='xsltSetXIncludeDefault' type='function'/>
     <exports symbol='xsltCopyOf' type='function'/>
     <exports symbol='xsltApplyTemplates' type='function'/>
     <exports symbol='xsltIf' type='function'/>
     <exports symbol='xsltCallTemplate' type='function'/>
     <exports symbol='xsltApplyStylesheet' type='function'/>
     <exports symbol='xsltApplyStripSpaces' type='function'/>
     <exports symbol='xsltLocalVariablePush' type='function'/>
     <exports symbol='xsltFreeTransformContext' type='function'/>
     <exports symbol='xsltRunStylesheet' type='function'/>
     <exports symbol='xsltChoose' type='function'/>
     <exports symbol='xsltCopyTextString' type='function'/>
     <exports symbol='xsltText' type='function'/>
     <exports symbol='xsltProcessOneNode' type='function'/>
     <exports symbol='xsltLocalVariablePop' type='function'/>
     <exports symbol='xsltNumber' type='function'/>
     <exports symbol='xsltRunStylesheetUser' type='function'/>
     <exports symbol='xsltNewTransformContext' type='function'/>
     <exports symbol='xsltGetXIncludeDefault' type='function'/>
     <exports symbol='xsltApplyOneTemplate' type='function'/>
     <exports symbol='xslHandleDebugger' type='function'/>
     <exports symbol='xsltCopy' type='function'/>
     <exports symbol='xsltDocumentElem' type='function'/>
     <exports symbol='xsltAttribute' type='function'/>
     <exports symbol='xsltApplyImports' type='function'/>
     <exports symbol='xsltElement' type='function'/>
     <exports symbol='xsltProfileStylesheet' type='function'/>
     <exports symbol='xsltForEach' type='function'/>
     <exports symbol='xsltApplyStylesheetUser' type='function'/>
     <exports symbol='xsltProcessingInstruction' type='function'/>
     <exports symbol='xsltComment' type='function'/>
    </file>
    <file name='variables'>
     <summary>interface for the variable matching and lookup.</summary>
     <description>interface for the variable matching and lookup. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_REGISTER_VARIABLE_LOOKUP' type='macro'/>
     <exports symbol='XSLT_RVT_FUNC_RESULT' type='macro'/>
     <exports symbol='XSLT_RVT_GLOBAL' type='macro'/>
     <exports symbol='XSLT_RVT_LOCAL' type='macro'/>
     <exports symbol='xsltFreeGlobalVariables' type='function'/>
     <exports symbol='xsltQuoteUserParams' type='function'/>
     <exports symbol='xsltXPathVariableLookup' type='function'/>
     <exports symbol='xsltEvalUserParams' type='function'/>
     <exports symbol='xsltParseStylesheetCallerParam' type='function'/>
     <exports symbol='xsltAddStackElemList' type='function'/>
     <exports symbol='xsltParseGlobalVariable' type='function'/>
     <exports symbol='xsltQuoteOneUserParam' type='function'/>
     <exports symbol='xsltParseGlobalParam' type='function'/>
     <exports symbol='xsltParseStylesheetVariable' type='function'/>
     <exports symbol='xsltEvalGlobalVariables' type='function'/>
     <exports symbol='xsltEvalOneUserParam' type='function'/>
     <exports symbol='xsltParseStylesheetParam' type='function'/>
     <exports symbol='xsltVariableLookup' type='function'/>
    </file>
    <file name='xslt'>
     <summary>Interfaces, constants and types related to the XSLT engine</summary>
     <description>Interfaces, constants and types related to the XSLT engine </description>
     <author>Daniel Veillard </author>
     <exports symbol='XSLT_DEFAULT_VERSION' type='macro'/>
     <exports symbol='XSLT_DEFAULT_VENDOR' type='macro'/>
     <exports symbol='XSLT_PARSE_OPTIONS' type='macro'/>
     <exports symbol='XSLT_DEFAULT_URL' type='macro'/>
     <exports symbol='XSLT_NAMESPACE' type='macro'/>
     <exports symbol='xsltLibxmlVersion' type='variable'/>
     <exports symbol='xsltEngineVersion' type='variable'/>
     <exports symbol='xsltLibxsltVersion' type='variable'/>
     <exports symbol='xsltMaxDepth' type='variable'/>
     <exports symbol='xsltMaxVars' type='variable'/>
     <exports symbol='xsltCleanupGlobals' type='function'/>
     <exports symbol='xsltInit' type='function'/>
    </file>
    <file name='xsltInternals'>
     <summary>internal data structures, constants and functions</summary>
     <description>Internal data structures, constants and functions used by the XSLT engine. They are not part of the API or ABI, i.e. they can change without prior notice, use carefully. </description>
     <author>Daniel Veillard </author>
     <exports symbol='CHECK_STOPPED0' type='macro'/>
     <exports symbol='XSLT_PAT_NO_PRIORITY' type='macro'/>
     <exports symbol='XSLT_ITEM_NSINSCOPE_FIELDS' type='macro'/>
     <exports symbol='XSLT_IS_TEXT_NODE' type='macro'/>
     <exports symbol='IS_XSLT_ELEM_FAST' type='macro'/>
     <exports symbol='XSLT_REFACTORED_VARS' type='macro'/>
     <exports symbol='XSLT_RUNTIME_EXTRA_LST' type='macro'/>
     <exports symbol='XSLT_ITEM_COMPATIBILITY_FIELDS' type='macro'/>
     <exports symbol='IS_XSLT_ATTR_FAST' type='macro'/>
     <exports symbol='XSLT_HAS_INTERNAL_NSMAP' type='macro'/>
     <exports symbol='XSLT_FAST_IF' type='macro'/>
     <exports symbol='XSLT_MARK_RES_TREE_FRAG' type='macro'/>
     <exports symbol='XSLT_GET_INTERNAL_NSMAP' type='macro'/>
     <exports symbol='XSLT_REFACTORED_KEYCOMP' type='macro'/>
     <exports symbol='XSLT_ITEM_NAVIGATION_FIELDS' type='macro'/>
     <exports symbol='XSLT_MAX_SORT' type='macro'/>
     <exports symbol='XSLT_RUNTIME_EXTRA' type='macro'/>
     <exports symbol='XSLT_IS_RES_TREE_FRAG' type='macro'/>
     <exports symbol='XML_CAST_FPTR' type='macro'/>
     <exports symbol='XSLT_ITEM_COMMON_FIELDS' type='macro'/>
     <exports symbol='CHECK_STOPPED' type='macro'/>
     <exports symbol='XSLT_RUNTIME_EXTRA_FREE' type='macro'/>
     <exports symbol='XSLT_CCTXT' type='macro'/>
     <exports symbol='CHECK_STOPPEDE' type='macro'/>
     <exports symbol='XSLT_ERROR_SEVERITY_ERROR' type='enum'/>
     <exports symbol='XSLT_FUNC_ELEMENT' type='enum'/>
     <exports symbol='XSLT_FUNC_VALUEOF' type='enum'/>
     <exports symbol='XSLT_FUNC_WITHPARAM' type='enum'/>
     <exports symbol='XSLT_OUTPUT_XML' type='enum'/>
     <exports symbol='XSLT_STATE_ERROR' type='enum'/>
     <exports symbol='XSLT_OUTPUT_HTML' type='enum'/>
     <exports symbol='XSLT_FUNC_LITERAL_RESULT_ELEMENT' type='enum'/>
     <exports symbol='XSLT_STATE_OK' type='enum'/>
     <exports symbol='XSLT_FUNC_FOREACH' type='enum'/>
     <exports symbol='XSLT_FUNC_CHOOSE' type='enum'/>
     <exports symbol='XSLT_FUNC_SORT' type='enum'/>
     <exports symbol='XSLT_STATE_STOPPED' type='enum'/>
     <exports symbol='XSLT_ERROR_SEVERITY_WARNING' type='enum'/>
     <exports symbol='XSLT_FUNC_ATTRSET' type='enum'/>
     <exports symbol='XSLT_FUNC_NUMBER' type='enum'/>
     <exports symbol='XSLT_FUNC_ATTRIBUTE' type='enum'/>
     <exports symbol='XSLT_FUNC_APPLYTEMPLATES' type='enum'/>
     <exports symbol='XSLT_FUNC_INCLUDE' type='enum'/>
     <exports symbol='XSLT_FUNC_WHEN' type='enum'/>
     <exports symbol='XSLT_FUNC_APPLYIMPORTS' type='enum'/>
     <exports symbol='XSLT_FUNC_COPY' type='enum'/>
     <exports symbol='XSLT_FUNC_EXTENSION' type='enum'/>
     <exports symbol='XSLT_FUNC_OTHERWISE' type='enum'/>
     <exports symbol='XSLT_FUNC_COPYOF' type='enum'/>
     <exports symbol='XSLT_OUTPUT_TEXT' type='enum'/>
     <exports symbol='XSLT_FUNC_PARAM' type='enum'/>
     <exports symbol='XSLT_FUNC_COMMENT' type='enum'/>
     <exports symbol='XSLT_FUNC_MESSAGE' type='enum'/>
     <exports symbol='XSLT_FUNC_DOCUMENT' type='enum'/>
     <exports symbol='XSLT_FUNC_IF' type='enum'/>
     <exports symbol='XSLT_FUNC_PI' type='enum'/>
     <exports symbol='XSLT_FUNC_UNKOWN_FORWARDS_COMPAT' type='enum'/>
     <exports symbol='XSLT_FUNC_TEXT' type='enum'/>
     <exports symbol='XSLT_FUNC_VARIABLE' type='enum'/>
     <exports symbol='XSLT_FUNC_FALLBACK' type='enum'/>
     <exports symbol='XSLT_FUNC_CALLTEMPLATE' type='enum'/>
     <exports symbol='xsltElemPreComp' type='typedef'/>
     <exports symbol='xsltStyleItemPIPtr' type='typedef'/>
     <exports symbol='xsltDocument' type='typedef'/>
     <exports symbol='xsltStyleItemDocument' type='typedef'/>
     <exports symbol='xsltStyleItemMessagePtr' type='typedef'/>
     <exports symbol='xsltStyleItemNumberPtr' type='typedef'/>
     <exports symbol='xsltStyleBasicItemVariablePtr' type='typedef'/>
     <exports symbol='xsltStyleItemForEachPtr' type='typedef'/>
     <exports symbol='xsltTransformState' type='typedef'/>
     <exports symbol='xsltCompilerNodeInfoPtr' type='typedef'/>
     <exports symbol='xsltStyleItemLRElementInfoPtr' type='typedef'/>
     <exports symbol='xsltRuntimeExtraPtr' type='typedef'/>
     <exports symbol='xsltStyleItemLRElementInfo' type='typedef'/>
     <exports symbol='xsltStyleItemWithParamPtr' type='typedef'/>
     <exports symbol='xsltStyleItemCommentPtr' type='typedef'/>
     <exports symbol='xsltStyleItemMessage' type='typedef'/>
     <exports symbol='xsltStyleItemParamPtr' type='typedef'/>
     <exports symbol='xsltStyleItemCopyOf' type='typedef'/>
     <exports symbol='xsltStyleItemCallTemplatePtr' type='typedef'/>
     <exports symbol='xsltTransformCache' type='typedef'/>
     <exports symbol='xsltStyleItemCopyOfPtr' type='typedef'/>
     <exports symbol='xsltNsMap' type='typedef'/>
     <exports symbol='xsltEffectiveNs' type='typedef'/>
     <exports symbol='xsltStyleItemApplyImportsPtr' type='typedef'/>
     <exports symbol='xsltStylesheet' type='typedef'/>
     <exports symbol='xsltStylePreCompPtr' type='typedef'/>
     <exports symbol='xsltNsMapPtr' type='typedef'/>
     <exports symbol='xsltDecimalFormatPtr' type='typedef'/>
     <exports symbol='xsltStyleItemIncludePtr' type='typedef'/>
     <exports symbol='xsltKeyTablePtr' type='typedef'/>
     <exports symbol='xsltStyleItemTextPtr' type='typedef'/>
     <exports symbol='xsltCompilerNodeInfo' type='typedef'/>
     <exports symbol='xsltStylesheetPtr' type='typedef'/>
     <exports symbol='xsltTemplatePtr' type='typedef'/>
     <exports symbol='xsltStyleBasicEmptyItem' type='typedef'/>
     <exports symbol='xsltStackElem' type='typedef'/>
     <exports symbol='xsltStyleItemIfPtr' type='typedef'/>
     <exports symbol='xsltStyleItemWhenPtr' type='typedef'/>
     <exports symbol='xsltStyleItemElementPtr' type='typedef'/>
     <exports symbol='xsltStyleItemOtherwise' type='typedef'/>
     <exports symbol='xsltStyleItemCopy' type='typedef'/>
     <exports symbol='xsltKeyDefPtr' type='typedef'/>
     <exports symbol='xsltVarInfoPtr' type='typedef'/>
     <exports symbol='xsltStyleItemSort' type='typedef'/>
     <exports symbol='xsltTransformCachePtr' type='typedef'/>
     <exports symbol='xsltStyleItemExtElementPtr' type='typedef'/>
     <exports symbol='xsltNsAliasPtr' type='typedef'/>
     <exports symbol='xsltStyleItemValueOfPtr' type='typedef'/>
     <exports symbol='xsltDocumentPtr' type='typedef'/>
     <exports symbol='xsltPointerListPtr' type='typedef'/>
     <exports symbol='xsltTemplate' type='typedef'/>
     <exports symbol='xsltStyleBasicExpressionItemPtr' type='typedef'/>
     <exports symbol='xsltRuntimeExtra' type='typedef'/>
     <exports symbol='xsltStyleItemAttributePtr' type='typedef'/>
     <exports symbol='xsltTransformContext' type='typedef'/>
     <exports symbol='xsltPointerList' type='typedef'/>
     <exports symbol='xsltStyleItemUknown' type='typedef'/>
     <exports symbol='xsltErrorSeverityType' type='typedef'/>
     <exports symbol='xsltElemPreCompPtr' type='typedef'/>
     <exports symbol='xsltStyleItemFallback' type='typedef'/>
     <exports symbol='xsltStyleItemOtherwisePtr' type='typedef'/>
     <exports symbol='xsltStyleItemWhen' type='typedef'/>
     <exports symbol='xsltStyleItemIf' type='typedef'/>
     <exports symbol='xsltTransformContextPtr' type='typedef'/>
     <exports symbol='xsltNsList' type='typedef'/>
     <exports symbol='xsltStyleItemForEach' type='typedef'/>
     <exports symbol='xsltStyleItemExtElement' type='typedef'/>
     <exports symbol='xsltNsListContainerPtr' type='typedef'/>
     <exports symbol='xsltStyleBasicExpressionItem' type='typedef'/>
     <exports symbol='xsltStyleItemWithParam' type='typedef'/>
     <exports symbol='xsltStyleItemElement' type='typedef'/>
     <exports symbol='xsltCompilerCtxt' type='typedef'/>
     <exports symbol='xsltStyleItemComment' type='typedef'/>
     <exports symbol='xsltEffectiveNsPtr' type='typedef'/>
     <exports symbol='xsltStyleItemVariable' type='typedef'/>
     <exports symbol='xsltStyleItemVariablePtr' type='typedef'/>
     <exports symbol='xsltStyleItemParam' type='typedef'/>
     <exports symbol='xsltNsListContainer' type='typedef'/>
     <exports symbol='xsltStackElemPtr' type='typedef'/>
     <exports symbol='xsltStyleBasicEmptyItemPtr' type='typedef'/>
     <exports symbol='xsltStyleItemText' type='typedef'/>
     <exports symbol='xsltStyleItemCopyPtr' type='typedef'/>
     <exports symbol='xsltStyleItemSortPtr' type='typedef'/>
     <exports symbol='xsltPrincipalStylesheetData' type='typedef'/>
     <exports symbol='xsltOutputType' type='typedef'/>
     <exports symbol='xsltPrincipalStylesheetDataPtr' type='typedef'/>
     <exports symbol='xsltStyleBasicItemVariable' type='typedef'/>
     <exports symbol='xsltStyleItemChoosePtr' type='typedef'/>
     <exports symbol='xsltNsAlias' type='typedef'/>
     <exports symbol='xsltVarInfo' type='typedef'/>
     <exports symbol='xsltStyleItemApplyImports' type='typedef'/>
     <exports symbol='xsltKeyTable' type='typedef'/>
     <exports symbol='xsltStylePreComp' type='typedef'/>
     <exports symbol='xsltNsListPtr' type='typedef'/>
     <exports symbol='xsltKeyDef' type='typedef'/>
     <exports symbol='xsltDecimalFormat' type='typedef'/>
     <exports symbol='xsltStyleItemApplyTemplatesPtr' type='typedef'/>
     <exports symbol='xsltStyleItemUknownPtr' type='typedef'/>
     <exports symbol='xsltStyleItemValueOf' type='typedef'/>
     <exports symbol='xsltCompilerCtxtPtr' type='typedef'/>
     <exports symbol='xsltStyleItemAttribute' type='typedef'/>
     <exports symbol='xsltStyleItemDocumentPtr' type='typedef'/>
     <exports symbol='xsltStyleItemCallTemplate' type='typedef'/>
     <exports symbol='xsltStyleItemFallbackPtr' type='typedef'/>
     <exports symbol='xsltStyleItemNumber' type='typedef'/>
     <exports symbol='xsltStyleItemApplyTemplates' type='typedef'/>
     <exports symbol='xsltStyleItemChoose' type='typedef'/>
     <exports symbol='xsltStyleType' type='typedef'/>
     <exports symbol='xsltStyleItemPI' type='typedef'/>
     <exports symbol='xsltStyleItemInclude' type='typedef'/>
     <exports symbol='_xsltPointerList' type='struct'/>
     <exports symbol='_xsltStyleItemSort' type='struct'/>
     <exports symbol='_xsltNsAlias' type='struct'/>
     <exports symbol='_xsltTemplate' type='struct'/>
     <exports symbol='_xsltStyleItemWhen' type='struct'/>
     <exports symbol='_xsltVarInfo' type='struct'/>
     <exports symbol='_xsltNsList' type='struct'/>
     <exports symbol='_xsltStyleItemInclude' type='struct'/>
     <exports symbol='_xsltEffectiveNs' type='struct'/>
     <exports symbol='_xsltDecimalFormat' type='struct'/>
     <exports symbol='_xsltStyleItemAttribute' type='struct'/>
     <exports symbol='_xsltStyleItemValueOf' type='struct'/>
     <exports symbol='_xsltStyleItemDocument' type='struct'/>
     <exports symbol='_xsltStyleItemMessage' type='struct'/>
     <exports symbol='_xsltStyleItemCopy' type='struct'/>
     <exports symbol='_xsltStyleItemText' type='struct'/>
     <exports symbol='_xsltStyleBasicExpressionItem' type='struct'/>
     <exports symbol='_xsltStylesheet' type='struct'/>
     <exports symbol='_xsltNsListContainer' type='struct'/>
     <exports symbol='_xsltStyleItemCallTemplate' type='struct'/>
     <exports symbol='_xsltStyleItemApplyTemplates' type='struct'/>
     <exports symbol='_xsltElemPreComp' type='struct'/>
     <exports symbol='_xsltCompilerCtxt' type='struct'/>
     <exports symbol='_xsltKeyTable' type='struct'/>
     <exports symbol='_xsltStyleItemUknown' type='struct'/>
     <exports symbol='_xsltStyleItemNumber' type='struct'/>
     <exports symbol='_xsltStylePreComp' type='struct'/>
     <exports symbol='_xsltTransformCache' type='struct'/>
     <exports symbol='_xsltCompilerNodeInfo' type='struct'/>
     <exports symbol='_xsltNsMap' type='struct'/>
     <exports symbol='_xsltStyleItemElement' type='struct'/>
     <exports symbol='_xsltStyleItemPI' type='struct'/>
     <exports symbol='_xsltStyleItemExtElement' type='struct'/>
     <exports symbol='_xsltStyleItemParam' type='struct'/>
     <exports symbol='_xsltStackElem' type='struct'/>
     <exports symbol='_xsltTransformContext' type='struct'/>
     <exports symbol='_xsltStyleItemIf' type='struct'/>
     <exports symbol='_xsltStyleBasicItemVariable' type='struct'/>
     <exports symbol='_xsltRuntimeExtra' type='struct'/>
     <exports symbol='_xsltKeyDef' type='struct'/>
     <exports symbol='_xsltPrincipalStylesheetData' type='struct'/>
     <exports symbol='_xsltStyleItemLRElementInfo' type='struct'/>
     <exports symbol='_xsltStyleItemOtherwise' type='struct'/>
     <exports symbol='_xsltDocument' type='struct'/>
     <exports symbol='_xsltStyleBasicEmptyItem' type='struct'/>
     <exports symbol='xsltXSLTAttrMarker' type='variable'/>
     <exports symbol='xsltConstNamespaceNameXSLT' type='variable'/>
     <exports symbol='xsltElemPreCompDeallocator' type='function'/>
     <exports symbol='xsltRegisterPersistRVT' type='function'/>
     <exports symbol='xsltParseStylesheetImportedDoc' type='function'/>
     <exports symbol='xsltFreeStackElemList' type='function'/>
     <exports symbol='xsltAllocateExtra' type='function'/>
     <exports symbol='xsltFlagRVTs' type='function'/>
     <exports symbol='xsltParseSequenceConstructor' type='function'/>
     <exports symbol='xsltRegisterTmpRVT' type='function'/>
     <exports symbol='xsltInitAllDocKeys' type='function'/>
     <exports symbol='xsltDecimalFormatGetByName' type='function'/>
     <exports symbol='xsltExtensionInstructionResultFinalize' type='function'/>
     <exports symbol='xsltParseStylesheetUser' type='function'/>
     <exports symbol='xsltPointerListFree' type='function'/>
     <exports symbol='xsltIsBlank' type='function'/>
     <exports symbol='xsltFormatNumberConversion' type='function'/>
     <exports symbol='xsltPointerListAddSize' type='function'/>
     <exports symbol='xsltSortFunc' type='function'/>
     <exports symbol='xsltUninit' type='function'/>
     <exports symbol='xsltFreeStylesheet' type='function'/>
     <exports symbol='xsltCreateRVT' type='function'/>
     <exports symbol='xsltParseStylesheetFile' type='function'/>
     <exports symbol='xsltParseStylesheetOutput' type='function'/>
     <exports symbol='xsltParseAnyXSLTElem' type='function'/>
     <exports symbol='xsltCompileAttr' type='function'/>
     <exports symbol='xsltRestoreDocumentNamespaces' type='function'/>
     <exports symbol='xsltNumberFormat' type='function'/>
     <exports symbol='xsltReleaseRVT' type='function'/>
     <exports symbol='xsltFreeRVTs' type='function'/>
     <exports symbol='xsltExtensionInstructionResultRegister' type='function'/>
     <exports symbol='xsltPointerListCreate' type='function'/>
     <exports symbol='xsltFreeAVTList' type='function'/>
     <exports symbol='xsltAllocateExtraCtxt' type='function'/>
     <exports symbol='xsltParseTemplateContent' type='function'/>
     <exports symbol='xsltNewStylesheet' type='function'/>
     <exports symbol='xsltParseStylesheetProcess' type='function'/>
     <exports symbol='xsltDecimalFormatGetByQName' type='function'/>
     <exports symbol='xsltTransformFunction' type='function'/>
     <exports symbol='xsltRegisterLocalRVT' type='function'/>
     <exports symbol='xsltParseStylesheetDoc' type='function'/>
     <exports symbol='xsltInitCtxtKey' type='function'/>
     <exports symbol='xsltEvalAVT' type='function'/>
     <exports symbol='xsltPointerListClear' type='function'/>
     <exports symbol='xsltLoadStylesheetPI' type='function'/>
    </file>
    <file name='xsltexports'>
     <summary>macros for marking symbols as exportable/importable.</summary>
     <description>macros for marking symbols as exportable/importable. </description>
     <author>Igor Zlatkovic &lt;igor@zlatkovic.com&gt; </author>
     <exports symbol='LIBXSLT_PUBLIC' type='macro'/>
     <exports symbol='XSLTPUBFUN' type='macro'/>
     <exports symbol='XSLTPUBVAR' type='macro'/>
     <exports symbol='_REENTRANT' type='macro'/>
     <exports symbol='XSLTCALL' type='macro'/>
    </file>
    <file name='xsltlocale'>
     <summary>Locale handling</summary>
     <description>Interfaces for locale handling. Needed for language dependent sorting. </description>
     <author>Nick Wellnhofer </author>
     <exports symbol='XSLT_LOCALE_WINAPI' type='macro'/>
     <exports symbol='XSLT_LOCALE_NONE' type='macro'/>
     <exports symbol='XSLT_LOCALE_POSIX' type='macro'/>
     <exports symbol='xsltLocale' type='typedef'/>
     <exports symbol='xsltLocaleChar' type='typedef'/>
     <exports symbol='xsltNewLocale' type='function'/>
     <exports symbol='xsltLocaleStrcmp' type='function'/>
     <exports symbol='xsltFreeLocale' type='function'/>
     <exports symbol='xsltStrxfrm' type='function'/>
     <exports symbol='xsltFreeLocales' type='function'/>
    </file>
    <file name='xsltutils'>
     <summary>set of utilities for the XSLT engine</summary>
     <description>interfaces for the utilities module of the XSLT engine. things like message handling, profiling, and other generally useful routines. </description>
     <author>Daniel Veillard </author>
     <exports symbol='IS_XSLT_REAL_NODE' type='macro'/>
     <exports symbol='IS_XSLT_ELEM' type='macro'/>
     <exports symbol='IS_XSLT_NAME' type='macro'/>
     <exports symbol='XSLT_TODO' type='macro'/>
     <exports symbol='XSLT_STRANGE' type='macro'/>
     <exports symbol='XSLT_TIMESTAMP_TICS_PER_SEC' type='macro'/>
     <exports symbol='XSLT_TRACE' type='macro'/>
     <exports symbol='XSLT_TRACE_KEYS' type='enum'/>
     <exports symbol='XSLT_DEBUG_NEXT' type='enum'/>
     <exports symbol='XSLT_TRACE_COPY_OF' type='enum'/>
     <exports symbol='XSLT_TRACE_FOR_EACH' type='enum'/>
     <exports symbol='XSLT_DEBUG_STEPOUT' type='enum'/>
     <exports symbol='XSLT_DEBUG_RUN' type='enum'/>
     <exports symbol='XSLT_TRACE_APPLY_TEMPLATES' type='enum'/>
     <exports symbol='XSLT_TRACE_CHOOSE' type='enum'/>
     <exports symbol='XSLT_DEBUG_INIT' type='enum'/>
     <exports symbol='XSLT_DEBUG_RUN_RESTART' type='enum'/>
     <exports symbol='XSLT_TRACE_ALL' type='enum'/>
     <exports symbol='XSLT_TRACE_CALL_TEMPLATE' type='enum'/>
     <exports symbol='XSLT_TRACE_IF' type='enum'/>
     <exports symbol='XSLT_TRACE_PROCESS_NODE' type='enum'/>
     <exports symbol='XSLT_TRACE_COPY_TEXT' type='enum'/>
     <exports symbol='XSLT_TRACE_APPLY_TEMPLATE' type='enum'/>
     <exports symbol='XSLT_DEBUG_CONT' type='enum'/>
     <exports symbol='XSLT_TRACE_VALUE_OF' type='enum'/>
     <exports symbol='XSLT_DEBUG_STEP' type='enum'/>
     <exports symbol='XSLT_TRACE_STRIP_SPACES' type='enum'/>
     <exports symbol='XSLT_DEBUG_STOP' type='enum'/>
     <exports symbol='XSLT_TRACE_COPY' type='enum'/>
     <exports symbol='XSLT_TRACE_NONE' type='enum'/>
     <exports symbol='XSLT_DEBUG_NONE' type='enum'/>
     <exports symbol='XSLT_TRACE_PI' type='enum'/>
     <exports symbol='XSLT_TRACE_COMMENT' type='enum'/>
     <exports symbol='XSLT_TRACE_VARIABLES' type='enum'/>
     <exports symbol='XSLT_DEBUG_QUIT' type='enum'/>
     <exports symbol='XSLT_TRACE_TEMPLATES' type='enum'/>
     <exports symbol='xsltDebugTraceCodes' type='typedef'/>
     <exports symbol='xsltDebugStatusCodes' type='typedef'/>
     <exports symbol='xsltGenericError' type='variable'/>
     <exports symbol='xsltGenericDebug' type='variable'/>
     <exports symbol='xsltGenericErrorContext' type='variable'/>
     <exports symbol='xslDebugStatus' type='variable'/>
     <exports symbol='xsltGenericDebugContext' type='variable'/>
     <exports symbol='xsltSaveResultToFile' type='function'/>
     <exports symbol='xsltSetGenericErrorFunc' type='function'/>
     <exports symbol='xsltSetDebuggerCallbacks' type='function'/>
     <exports symbol='xsltSaveResultTo' type='function'/>
     <exports symbol='xsltTransformError' type='function'/>
     <exports symbol='xslAddCall' type='function'/>
     <exports symbol='xsltDocumentSortFunction' type='function'/>
     <exports symbol='xsltGetQNameURI2' type='function'/>
     <exports symbol='xsltComputeSortResult' type='function'/>
     <exports symbol='xsltPrintErrorContext' type='function'/>
     <exports symbol='xsltGetUTF8Char' type='function'/>
     <exports symbol='xsltDefaultSortFunction' type='function'/>
     <exports symbol='xsltSaveResultToFd' type='function'/>
     <exports symbol='xsltSetCtxtSortFunc' type='function'/>
     <exports symbol='xsltGetNsProp' type='function'/>
     <exports symbol='xsltGetCNsProp' type='function'/>
     <exports symbol='xsltGetQNameURI' type='function'/>
     <exports symbol='xsltAddCallCallback' type='function'/>
     <exports symbol='xsltCalibrateAdjust' type='function'/>
     <exports symbol='xsltSaveProfiling' type='function'/>
     <exports symbol='xsltSaveResultToString' type='function'/>
     <exports symbol='xsltSplitQName' type='function'/>
     <exports symbol='xsltDoSortFunction' type='function'/>
     <exports symbol='xsltDebugGetDefaultTrace' type='function'/>
     <exports symbol='xsltMessage' type='function'/>
     <exports symbol='xsltGetDebuggerStatus' type='function'/>
     <exports symbol='xsltTimestamp' type='function'/>
     <exports symbol='xsltSetTransformErrorFunc' type='function'/>
     <exports symbol='xsltXPathCompile' type='function'/>
     <exports symbol='xsltDebugSetDefaultTrace' type='function'/>
     <exports symbol='xsltSetGenericDebugFunc' type='function'/>
     <exports symbol='xsltXPathCompileFlags' type='function'/>
     <exports symbol='xsltSetCtxtParseOptions' type='function'/>
     <exports symbol='xsltSetDebuggerStatus' type='function'/>
     <exports symbol='xslDropCall' type='function'/>
     <exports symbol='xsltSetSortFunc' type='function'/>
     <exports symbol='xsltHandleDebuggerCallback' type='function'/>
     <exports symbol='xsltSaveResultToFilename' type='function'/>
     <exports symbol='xsltDropCallCallback' type='function'/>
     <exports symbol='xsltGetProfileInformation' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='CHECK_STOPPED' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function.</info>
    </macro>
    <macro name='CHECK_STOPPED0' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function with a 0 value.</info>
    </macro>
    <macro name='CHECK_STOPPEDE' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will goto the error: label.</info>
    </macro>
    <macro name='IS_XSLT_ATTR_FAST' file='xsltInternals'>
      <info>quick check for xslt namespace attribute</info>
    </macro>
    <macro name='IS_XSLT_ELEM' file='xsltutils'>
      <info>Checks that the element pertains to XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_ELEM_FAST' file='xsltInternals'>
      <info>quick check whether this is an xslt element</info>
    </macro>
    <macro name='IS_XSLT_NAME' file='xsltutils'>
      <info>Checks the value of an element in XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_REAL_NODE' file='xsltutils'>
      <info>Check that a node is a &apos;real&apos; one: document, element, text or attribute.</info>
    </macro>
    <macro name='LIBXSLT_PUBLIC' file='xsltexports'>
    </macro>
    <macro name='NODE_IS_KEYED' file='keys'>
      <info>check for bit 15 set</info>
    </macro>
    <macro name='UNDEFINED_DEFAULT_NS' file='namespaces'>
      <info>Special value for undefined namespace, internal</info>
    </macro>
    <macro name='XML_CAST_FPTR' file='xsltInternals'>
      <info>Macro to do a casting from an object pointer to a function pointer without encountering a warning from gcc  #define XML_CAST_FPTR(fptr) (*(void **)(&amp;fptr)) This macro violated ISO C aliasing rules (gcc4 on s390 broke) so it is disabled now</info>
      <arg name='fptr' info='pointer to a function'/>
    </macro>
    <macro name='XSLTCALL' file='xsltexports'>
    </macro>
    <macro name='XSLTPUBFUN' file='xsltexports'>
    </macro>
    <macro name='XSLTPUBVAR' file='xsltexports'>
    </macro>
    <macro name='XSLT_CCTXT' file='xsltInternals'>
      <info>get pointer to compiler context</info>
    </macro>
    <macro name='XSLT_DEFAULT_URL' file='xslt'>
      <info>The XSLT &quot;vendor&quot; URL for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VENDOR' file='xslt'>
      <info>The XSLT &quot;vendor&quot; string for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VERSION' file='xslt'>
      <info>The default version of XSLT supported.</info>
    </macro>
    <macro name='XSLT_FAST_IF' file='xsltInternals'>
      <info>Internal define to enable usage of xmlXPathCompiledEvalToBoolean() for XSLT &quot;tests&quot;; e.g. in &lt;xsl:if test=&quot;/foo/bar&quot;&gt;</info>
    </macro>
    <macro name='XSLT_GET_IMPORT_INT' file='imports'>
      <info>A macro to import intergers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_GET_IMPORT_PTR' file='imports'>
      <info>A macro to import pointers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_GET_INTERNAL_NSMAP' file='xsltInternals'>
      <info>get pointer to namespace map</info>
    </macro>
    <macro name='XSLT_HAS_INTERNAL_NSMAP' file='xsltInternals'>
      <info>check for namespace mapping</info>
    </macro>
    <macro name='XSLT_IS_RES_TREE_FRAG' file='xsltInternals'>
      <info>internal macro to test tree fragments</info>
    </macro>
    <macro name='XSLT_IS_TEXT_NODE' file='xsltInternals'>
      <info>check if the argument is a text node</info>
    </macro>
    <macro name='XSLT_ITEM_COMMON_FIELDS' file='xsltInternals'>
      <info>Common fields used for all items.</info>
    </macro>
    <macro name='XSLT_ITEM_COMPATIBILITY_FIELDS' file='xsltInternals'>
      <info>Fields for API compatibility to the structure _xsltElemPreComp which is used for extension functions. Note that @next is used for storage; it does not reflect a next sibling in the tree. TODO: Evaluate if we really need such a compatibility.</info>
    </macro>
    <macro name='XSLT_ITEM_NAVIGATION_FIELDS' file='xsltInternals'>
      <info>Currently empty. TODO: It is intended to hold navigational fields in the future.</info>
    </macro>
    <macro name='XSLT_ITEM_NSINSCOPE_FIELDS' file='xsltInternals'>
      <info>The in-scope namespaces.</info>
    </macro>
    <macro name='XSLT_LIBXSLT_NAMESPACE' file='extra'>
      <info>This is the libxslt namespace for specific extensions.</info>
    </macro>
    <macro name='XSLT_LOCALE_NONE' file='xsltlocale'>
      <info>Macro indicating that there&apos;s no extended locale support</info>
    </macro>
    <macro name='XSLT_LOCALE_POSIX' file='xsltlocale'>
      <info>Macro indicating to use POSIX locale extensions</info>
    </macro>
    <macro name='XSLT_LOCALE_WINAPI' file='xsltlocale'>
      <info>Macro indicating to use WinAPI for extended locale support</info>
    </macro>
    <macro name='XSLT_MARK_RES_TREE_FRAG' file='xsltInternals'>
      <info>internal macro to set up tree fragments</info>
    </macro>
    <macro name='XSLT_MAX_SORT' file='xsltInternals'>
      <info>Max number of specified xsl:sort on an element.</info>
    </macro>
    <macro name='XSLT_NAMESPACE' file='xslt'>
      <info>The XSLT specification namespace.</info>
    </macro>
    <macro name='XSLT_PARSE_OPTIONS' file='xslt'>
      <info>The set of options to pass to an xmlReadxxx when loading files for XSLT consumption.</info>
    </macro>
    <macro name='XSLT_PAT_NO_PRIORITY' file='xsltInternals'>
      <info>Specific value for pattern without priority expressed.</info>
    </macro>
    <macro name='XSLT_REFACTORED_KEYCOMP' file='xsltInternals'>
      <info>Internal define to enable on-demand xsl:key computation. That&apos;s the only mode now but the define is kept for compatibility</info>
    </macro>
    <macro name='XSLT_REFACTORED_VARS' file='xsltInternals'>
      <info>Internal define to enable the refactored variable part of libxslt</info>
    </macro>
    <macro name='XSLT_REGISTER_FUNCTION_LOOKUP' file='functions'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_REGISTER_VARIABLE_LOOKUP' file='variables'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA' file='xsltInternals'>
      <info>Macro used to define extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA_FREE' file='xsltInternals'>
      <info>Macro used to free extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA_LST' file='xsltInternals'>
      <info>Macro used to access extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_RVT_FUNC_RESULT' file='variables'>
      <info>RVT is part of results returned with func:result. The RVT won&apos;t be destroyed after exiting a template and will be reset to XSLT_RVT_LOCAL or XSLT_RVT_VARIABLE in the template that receives the return value.</info>
    </macro>
    <macro name='XSLT_RVT_GLOBAL' file='variables'>
      <info>RVT is part of a global variable.</info>
    </macro>
    <macro name='XSLT_RVT_LOCAL' file='variables'>
      <info>RVT is destroyed after the current instructions ends.</info>
    </macro>
    <macro name='XSLT_SAXON_NAMESPACE' file='extra'>
      <info>This is Michael Kay&apos;s Saxon processor namespace for extensions.</info>
    </macro>
    <macro name='XSLT_STRANGE' file='xsltutils'>
      <info>Macro to flag that a problem was detected internally.</info>
    </macro>
    <macro name='XSLT_TIMESTAMP_TICS_PER_SEC' file='xsltutils'>
      <info>Sampling precision for profiling</info>
    </macro>
    <macro name='XSLT_TODO' file='xsltutils'>
      <info>Macro to flag unimplemented blocks.</info>
    </macro>
    <macro name='XSLT_TRACE' file='xsltutils'>
      <info>Control the type of xsl debugtrace messages emitted.</info>
    </macro>
    <macro name='XSLT_XALAN_NAMESPACE' file='extra'>
      <info>This is the Apache project XALAN processor namespace for extensions.</info>
    </macro>
    <macro name='XSLT_XT_NAMESPACE' file='extra'>
      <info>This is James Clark&apos;s XT processor namespace for extensions.</info>
    </macro>
    <macro name='_REENTRANT' file='xsltexports'>
    </macro>
    <enum name='XSLT_DEBUG_CONT' file='xsltutils' value='6' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_INIT' file='xsltutils' value='1' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_NEXT' file='xsltutils' value='4' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_NONE' file='xsltutils' value='0' type='xsltDebugStatusCodes' info='no debugging allowed'/>
    <enum name='XSLT_DEBUG_QUIT' file='xsltutils' value='9' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_RUN' file='xsltutils' value='7' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_RUN_RESTART' file='xsltutils' value='8' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STEP' file='xsltutils' value='2' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STEPOUT' file='xsltutils' value='3' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STOP' file='xsltutils' value='5' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_ERROR_SEVERITY_ERROR' file='xsltInternals' value='0' type='xsltErrorSeverityType'/>
    <enum name='XSLT_ERROR_SEVERITY_WARNING' file='xsltInternals' value='1' type='xsltErrorSeverityType'/>
    <enum name='XSLT_FUNC_APPLYIMPORTS' file='xsltInternals' value='11' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_APPLYTEMPLATES' file='xsltInternals' value='13' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_ATTRIBUTE' file='xsltInternals' value='5' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_ATTRSET' file='xsltInternals' value='27' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_CALLTEMPLATE' file='xsltInternals' value='12' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_CHOOSE' file='xsltInternals' value='14' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COMMENT' file='xsltInternals' value='6' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COPY' file='xsltInternals' value='1' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COPYOF' file='xsltInternals' value='8' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_DOCUMENT' file='xsltInternals' value='17' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_ELEMENT' file='xsltInternals' value='4' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_EXTENSION' file='xsltInternals' value='22' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_FALLBACK' file='xsltInternals' value='24' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_FOREACH' file='xsltInternals' value='16' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_IF' file='xsltInternals' value='15' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_INCLUDE' file='xsltInternals' value='26' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_LITERAL_RESULT_ELEMENT' file='xsltInternals' value='28' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_MESSAGE' file='xsltInternals' value='25' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_NUMBER' file='xsltInternals' value='10' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_OTHERWISE' file='xsltInternals' value='23' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_PARAM' file='xsltInternals' value='19' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_PI' file='xsltInternals' value='7' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_SORT' file='xsltInternals' value='2' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_TEXT' file='xsltInternals' value='3' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_UNKOWN_FORWARDS_COMPAT' file='xsltInternals' value='29' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_VALUEOF' file='xsltInternals' value='9' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_VARIABLE' file='xsltInternals' value='20' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_WHEN' file='xsltInternals' value='21' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_WITHPARAM' file='xsltInternals' value='18' type='xsltStyleType'/>
    <enum name='XSLT_LOAD_DOCUMENT' file='documents' value='2' type='xsltLoadType' info=' loading document at transformation time'/>
    <enum name='XSLT_LOAD_START' file='documents' value='0' type='xsltLoadType' info='loading for a top stylesheet'/>
    <enum name='XSLT_LOAD_STYLESHEET' file='documents' value='1' type='xsltLoadType' info='loading for a stylesheet include/import'/>
    <enum name='XSLT_OUTPUT_HTML' file='xsltInternals' value='1' type='xsltOutputType'/>
    <enum name='XSLT_OUTPUT_TEXT' file='xsltInternals' value='2' type='xsltOutputType'/>
    <enum name='XSLT_OUTPUT_XML' file='xsltInternals' value='0' type='xsltOutputType'/>
    <enum name='XSLT_SECPREF_CREATE_DIRECTORY' file='security' value='3' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_READ_FILE' file='security' value='1' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_READ_NETWORK' file='security' value='4' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_WRITE_FILE' file='security' value='2' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_WRITE_NETWORK' file='security' value='5' type='xsltSecurityOption'/>
    <enum name='XSLT_STATE_ERROR' file='xsltInternals' value='1' type='xsltTransformState'/>
    <enum name='XSLT_STATE_OK' file='xsltInternals' value='0' type='xsltTransformState'/>
    <enum name='XSLT_STATE_STOPPED' file='xsltInternals' value='2' type='xsltTransformState'/>
    <enum name='XSLT_TRACE_ALL' file='xsltutils' value='-1' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_APPLY_TEMPLATE' file='xsltutils' value='4' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_APPLY_TEMPLATES' file='xsltutils' value='512' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_CALL_TEMPLATE' file='xsltutils' value='256' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_CHOOSE' file='xsltutils' value='1024' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_COMMENT' file='xsltutils' value='16' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_COPY' file='xsltutils' value='8' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_COPY_OF' file='xsltutils' value='64' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_COPY_TEXT' file='xsltutils' value='1' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_FOR_EACH' file='xsltutils' value='4096' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_IF' file='xsltutils' value='2048' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_KEYS' file='xsltutils' value='32768' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_NONE' file='xsltutils' value='0' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_PI' file='xsltutils' value='32' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_PROCESS_NODE' file='xsltutils' value='2' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_STRIP_SPACES' file='xsltutils' value='8192' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_TEMPLATES' file='xsltutils' value='16384' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_VALUE_OF' file='xsltutils' value='128' type='xsltDebugTraceCodes'/>
    <enum name='XSLT_TRACE_VARIABLES' file='xsltutils' value='65536' type='xsltDebugTraceCodes'/>
    <struct name='xsltCompMatch' file='pattern' type='struct _xsltCompMatch'>
    </struct>
    <typedef name='xsltCompMatchPtr' file='pattern' type='xsltCompMatch *'/>
    <struct name='xsltCompilerCtxt' file='xsltInternals' type='struct _xsltCompilerCtxt'>
      <field name='errorCtxt' type='void *' info='* used for error/warning reports; e.g. XSLT_ERROR_SEVERITY_WARNING'/>
      <field name='errSeverity' type='xsltErrorSeverityType' info=''/>
      <field name='warnings' type='int' info=' TODO: number of warnings found at
compilation'/>
      <field name='errors' type='int' info=' TODO: number of errors found at
compilation'/>
      <field name='dict' type='xmlDictPtr' info=''/>
      <field name='style' type='xsltStylesheetPtr' info=''/>
      <field name='simplified' type='int' info=' whether this is a simplified stylesheet TODO: structured/unstructured error contexts.'/>
      <field name='depth' type='int' info=' Current depth of processing'/>
      <field name='inode' type='xsltCompilerNodeInfoPtr' info=''/>
      <field name='inodeList' type='xsltCompilerNodeInfoPtr' info=''/>
      <field name='inodeLast' type='xsltCompilerNodeInfoPtr' info=''/>
      <field name='tmpList' type='xsltPointerListPtr' info='* The XSLT version as specified by the stylesheet&apos;s root element.
*'/>
      <field name='isInclude' type='int' info=''/>
      <field name='hasForwardsCompat' type='int' info=' whether forwards-compatible mode was used
in a parsing episode'/>
      <field name='maxNodeInfos' type='int' info=' TEMP TODO: just for the interest'/>
      <field name='maxLREs' type='int' info='* In order to keep the old behaviour, applying strict rules of
* the spec can be turned off. This has effect only on special
* mechanisms like whitespace-stripping in the stylesheet.
*'/>
      <field name='strict' type='int' info=''/>
      <field name='psData' type='xsltPrincipalStylesheetDataPtr' info=''/>
      <field name='unknownItem' type='xsltStyleItemUknownPtr' info=''/>
      <field name='hasNsAliases' type='int' info=' Indicator if there was an xsl:namespace-alias.'/>
      <field name='nsAliases' type='xsltNsAliasPtr' info=''/>
      <field name='ivars' type='xsltVarInfoPtr' info=' Storage of local in-scope variables/params.'/>
      <field name='ivar' type='xsltVarInfoPtr' info=' topmost local variable/param.'/>
    </struct>
    <typedef name='xsltCompilerCtxtPtr' file='xsltInternals' type='xsltCompilerCtxt *'/>
    <struct name='xsltCompilerNodeInfo' file='xsltInternals' type='struct _xsltCompilerNodeInfo'>
      <field name='next' type='xsltCompilerNodeInfoPtr' info=''/>
      <field name='prev' type='xsltCompilerNodeInfoPtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='depth' type='int' info=''/>
      <field name='templ' type='xsltTemplatePtr' info=' The owning template'/>
      <field name='category' type='int' info=' XSLT element, LR-element or
extension element'/>
      <field name='type' type='xsltStyleType' info=''/>
      <field name='item' type='xsltElemPreCompPtr' info=' The compiled information The current in-scope namespaces'/>
      <field name='inScopeNs' type='xsltNsListContainerPtr' info=' The current excluded result namespaces'/>
      <field name='exclResultNs' type='xsltPointerListPtr' info=' The current extension instruction namespaces'/>
      <field name='extElemNs' type='xsltPointerListPtr' info=' The current info for literal result elements.'/>
      <field name='litResElemInfo' type='xsltStyleItemLRElementInfoPtr' info='* Set to 1 if in-scope namespaces changed,
*  or excluded result namespaces changed,
*  or extension element namespaces changed.
* This will trigger creation of new infos
*  for literal result elements.
*'/>
      <field name='nsChanged' type='int' info=''/>
      <field name='preserveWhitespace' type='int' info=''/>
      <field name='stripWhitespace' type='int' info=''/>
      <field name='isRoot' type='int' info=' whether this is the stylesheet&apos;s root node'/>
      <field name='forwardsCompat' type='int' info=' whether forwards-compatible mode is enabled whether the content of an extension element was processed'/>
      <field name='extContentHandled' type='int' info=' the type of the current child'/>
      <field name='curChildType' type='xsltStyleType' info=''/>
    </struct>
    <typedef name='xsltCompilerNodeInfoPtr' file='xsltInternals' type='xsltCompilerNodeInfo *'/>
    <typedef name='xsltDebugStatusCodes' file='xsltutils' type='enum'/>
    <typedef name='xsltDebugTraceCodes' file='xsltutils' type='enum'/>
    <struct name='xsltDecimalFormat' file='xsltInternals' type='struct _xsltDecimalFormat'>
      <field name='next' type='struct _xsltDecimalFormat *' info=' chained list'/>
      <field name='name' type='xmlChar *' info=' Used for interpretation of pattern'/>
      <field name='digit' type='xmlChar *' info=''/>
      <field name='patternSeparator' type='xmlChar *' info=' May appear in result'/>
      <field name='minusSign' type='xmlChar *' info=''/>
      <field name='infinity' type='xmlChar *' info=''/>
      <field name='noNumber' type='xmlChar *' info=' Not-a-number Used for interpretation of pattern and may appear in result'/>
      <field name='decimalPoint' type='xmlChar *' info=''/>
      <field name='grouping' type='xmlChar *' info=''/>
      <field name='percent' type='xmlChar *' info=''/>
      <field name='permille' type='xmlChar *' info=''/>
      <field name='zeroDigit' type='xmlChar *' info=''/>
      <field name='nsUri' type='const xmlChar *' info=''/>
    </struct>
    <typedef name='xsltDecimalFormatPtr' file='xsltInternals' type='xsltDecimalFormat *'/>
    <struct name='xsltDocument' file='xsltInternals' type='struct _xsltDocument'>
      <field name='next' type='struct _xsltDocument *' info=' documents are kept in a chained list'/>
      <field name='main' type='int' info=' is this the main document'/>
      <field name='doc' type='xmlDocPtr' info=' the parsed document'/>
      <field name='keys' type='void *' info=' key tables storage'/>
      <field name='includes' type='struct _xsltDocument *' info=' subsidiary includes'/>
      <field name='preproc' type='int' info=' pre-processing already done'/>
      <field name='nbKeysComputed' type='int' info=''/>
    </struct>
    <typedef name='xsltDocumentPtr' file='xsltInternals' type='xsltDocument *'/>
    <struct name='xsltEffectiveNs' file='xsltInternals' type='struct _xsltEffectiveNs'>
      <field name='nextInStore' type='xsltEffectiveNsPtr' info=' storage next'/>
      <field name='next' type='xsltEffectiveNsPtr' info=' next item in the list'/>
      <field name='prefix' type='const xmlChar *' info=''/>
      <field name='nsName' type='const xmlChar *' info='* Indicates if eclared on the literal result element; dunno if really
* needed.
*'/>
      <field name='holdByElem' type='int' info=''/>
    </struct>
    <typedef name='xsltEffectiveNsPtr' file='xsltInternals' type='xsltEffectiveNs *'/>
    <struct name='xsltElemPreComp' file='xsltInternals' type='struct _xsltElemPreComp'>
      <field name='next' type='xsltElemPreCompPtr' info=' next item in the global chained
list held by xsltStylesheet.'/>
      <field name='type' type='xsltStyleType' info=' type of the element'/>
      <field name='func' type='xsltTransformFunction' info=' handling function'/>
      <field name='inst' type='xmlNodePtr' info=' the node in the stylesheet&apos;s tree
corresponding to this item end of common part'/>
      <field name='free' type='xsltElemPreCompDeallocator' info=' the deallocator'/>
    </struct>
    <typedef name='xsltElemPreCompPtr' file='xsltInternals' type='xsltElemPreComp *'/>
    <typedef name='xsltErrorSeverityType' file='xsltInternals' type='enum'/>
    <struct name='xsltFormatNumberInfo' file='numbersInternals' type='struct _xsltFormatNumberInfo'>
      <field name='integer_hash' type='int' info=' Number of &apos;#&apos; in integer part'/>
      <field name='integer_digits' type='int' info=' Number of &apos;0&apos; in integer part'/>
      <field name='frac_digits' type='int' info=' Number of &apos;0&apos; in fractional part'/>
      <field name='frac_hash' type='int' info=' Number of &apos;#&apos; in fractional part'/>
      <field name='group' type='int' info=' Number of chars per display &apos;group&apos;'/>
      <field name='multiplier' type='int' info=' Scaling for percent or permille'/>
      <field name='add_decimal' type='char' info=' Flag for whether decimal point appears in pattern'/>
      <field name='is_multiplier_set' type='char' info=' Flag to catch multiple occurences of percent/permille'/>
      <field name='is_negative_pattern' type='char' info=' Flag for processing -ve prefix/suffix'/>
    </struct>
    <typedef name='xsltFormatNumberInfoPtr' file='numbersInternals' type='xsltFormatNumberInfo *'/>
    <struct name='xsltKeyDef' file='xsltInternals' type='struct _xsltKeyDef'>
      <field name='next' type='struct _xsltKeyDef *' info=''/>
      <field name='inst' type='xmlNodePtr' info=''/>
      <field name='name' type='xmlChar *' info=''/>
      <field name='nameURI' type='xmlChar *' info=''/>
      <field name='match' type='xmlChar *' info=''/>
      <field name='use' type='xmlChar *' info=''/>
      <field name='comp' type='xmlXPathCompExprPtr' info=''/>
      <field name='usecomp' type='xmlXPathCompExprPtr' info=''/>
      <field name='nsList' type='xmlNsPtr *' info=' the namespaces in scope'/>
      <field name='nsNr' type='int' info=' the number of namespaces in scope'/>
    </struct>
    <typedef name='xsltKeyDefPtr' file='xsltInternals' type='xsltKeyDef *'/>
    <struct name='xsltKeyTable' file='xsltInternals' type='struct _xsltKeyTable'>
      <field name='next' type='struct _xsltKeyTable *' info=''/>
      <field name='name' type='xmlChar *' info=''/>
      <field name='nameURI' type='xmlChar *' info=''/>
      <field name='keys' type='xmlHashTablePtr' info=''/>
    </struct>
    <typedef name='xsltKeyTablePtr' file='xsltInternals' type='xsltKeyTable *'/>
    <typedef name='xsltLoadType' file='documents' type='enum'/>
    <typedef name='xsltLocale' file='xsltlocale' type='void *'/>
    <typedef name='xsltLocaleChar' file='xsltlocale' type='xmlChar'/>
    <struct name='xsltNsAlias' file='xsltInternals' type='struct _xsltNsAlias'>
      <field name='next' type='xsltNsAliasPtr' info=' next in the list'/>
      <field name='literalNs' type='xmlNsPtr' info=''/>
      <field name='targetNs' type='xmlNsPtr' info=''/>
      <field name='docOfTargetNs' type='xmlDocPtr' info=''/>
    </struct>
    <typedef name='xsltNsAliasPtr' file='xsltInternals' type='xsltNsAlias *'/>
    <struct name='xsltNsList' file='xsltInternals' type='struct _xsltNsList'>
      <field name='next' type='xsltNsListPtr' info=' next in the list'/>
      <field name='ns' type='xmlNsPtr' info=''/>
    </struct>
    <struct name='xsltNsListContainer' file='xsltInternals' type='struct _xsltNsListContainer'>
      <field name='list' type='xmlNsPtr *' info=''/>
      <field name='totalNumber' type='int' info=''/>
      <field name='xpathNumber' type='int' info=''/>
    </struct>
    <typedef name='xsltNsListContainerPtr' file='xsltInternals' type='xsltNsListContainer *'/>
    <typedef name='xsltNsListPtr' file='xsltInternals' type='xsltNsList *'/>
    <struct name='xsltNsMap' file='xsltInternals' type='struct _xsltNsMap'>
      <field name='next' type='xsltNsMapPtr' info=' next in the list'/>
      <field name='doc' type='xmlDocPtr' info=''/>
      <field name='elem' type='xmlNodePtr' info=' the element holding the ns-decl'/>
      <field name='ns' type='xmlNsPtr' info=' the xmlNs structure holding the XML namespace name'/>
      <field name='origNsName' type='const xmlChar *' info=' the original XML namespace name'/>
      <field name='newNsName' type='const xmlChar *' info=' the mapped XML namespace name'/>
    </struct>
    <typedef name='xsltNsMapPtr' file='xsltInternals' type='xsltNsMap *'/>
    <struct name='xsltNumberData' file='numbersInternals' type='struct _xsltNumberData'>
      <field name='level' type='const xmlChar *' info=''/>
      <field name='count' type='const xmlChar *' info=''/>
      <field name='from' type='const xmlChar *' info=''/>
      <field name='value' type='const xmlChar *' info=''/>
      <field name='format' type='const xmlChar *' info=''/>
      <field name='has_format' type='int' info=''/>
      <field name='digitsPerGroup' type='int' info=''/>
      <field name='groupingCharacter' type='int' info=''/>
      <field name='groupingCharacterLen' type='int' info=''/>
      <field name='doc' type='xmlDocPtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='countPat' type='struct _xsltCompMatch *' info=''/>
      <field name='fromPat' type='struct _xsltCompMatch *' info='* accelerators
*'/>
    </struct>
    <typedef name='xsltNumberDataPtr' file='numbersInternals' type='xsltNumberData *'/>
    <typedef name='xsltOutputType' file='xsltInternals' type='enum'/>
    <struct name='xsltPointerList' file='xsltInternals' type='struct _xsltPointerList'>
      <field name='items' type='void **' info=''/>
      <field name='number' type='int' info=''/>
      <field name='size' type='int' info=''/>
    </struct>
    <typedef name='xsltPointerListPtr' file='xsltInternals' type='xsltPointerList *'/>
    <struct name='xsltPrincipalStylesheetData' file='xsltInternals' type='struct _xsltPrincipalStylesheetData'>
      <field name='namespaceDict' type='xmlDictPtr' info='* Global list of in-scope namespaces.
*'/>
      <field name='inScopeNamespaces' type='xsltPointerListPtr' info='* Global list of information for [xsl:]excluded-result-prefixes.
*'/>
      <field name='exclResultNamespaces' type='xsltPointerListPtr' info='* Global list of information for [xsl:]extension-element-prefixes.
*'/>
      <field name='extElemNamespaces' type='xsltPointerListPtr' info=''/>
      <field name='effectiveNs' type='xsltEffectiveNsPtr' info='* Namespace name map to get rid of string comparison of namespace names.
*'/>
      <field name='nsMap' type='xsltNsMapPtr' info=''/>
    </struct>
    <typedef name='xsltPrincipalStylesheetDataPtr' file='xsltInternals' type='xsltPrincipalStylesheetData *'/>
    <struct name='xsltRuntimeExtra' file='xsltInternals' type='struct _xsltRuntimeExtra'>
      <field name='info' type='void *' info=' pointer to the extra data'/>
      <field name='deallocate' type='xmlFreeFunc' info=' pointer to the deallocation routine'/>
    </struct>
    <typedef name='xsltRuntimeExtraPtr' file='xsltInternals' type='xsltRuntimeExtra *'/>
    <typedef name='xsltSecurityOption' file='security' type='enum'/>
    <struct name='xsltSecurityPrefs' file='security' type='struct _xsltSecurityPrefs'/>
    <typedef name='xsltSecurityPrefsPtr' file='security' type='xsltSecurityPrefs *'/>
    <struct name='xsltStackElem' file='xsltInternals' type='struct _xsltStackElem'>
      <field name='next' type='struct _xsltStackElem *' info=' chained list'/>
      <field name='comp' type='xsltStylePreCompPtr' info=' the compiled form'/>
      <field name='computed' type='int' info=' was the evaluation done'/>
      <field name='name' type='const xmlChar *' info=' the local part of the name QName'/>
      <field name='nameURI' type='const xmlChar *' info=' the URI part of the name QName'/>
      <field name='select' type='const xmlChar *' info=' the eval string'/>
      <field name='tree' type='xmlNodePtr' info=' the sequence constructor if no eval
string or the location'/>
      <field name='value' type='xmlXPathObjectPtr' info=' The value if computed'/>
      <field name='fragment' type='xmlDocPtr' info=' The Result Tree Fragments (needed for XSLT 1.0)
which are bound to the variable&apos;s lifetime.'/>
      <field name='level' type='int' info=' the depth in the tree;
-1 if persistent (e.g. a given xsl:with-param)'/>
      <field name='context' type='xsltTransformContextPtr' info=' The transformation context; needed to cache
the variables'/>
      <field name='flags' type='int' info=''/>
    </struct>
    <typedef name='xsltStackElemPtr' file='xsltInternals' type='xsltStackElem *'/>
    <struct name='xsltStyleBasicEmptyItem' file='xsltInternals' type='struct _xsltStyleBasicEmptyItem'>
    </struct>
    <typedef name='xsltStyleBasicEmptyItemPtr' file='xsltInternals' type='xsltStyleBasicEmptyItem *'/>
    <struct name='xsltStyleBasicExpressionItem' file='xsltInternals' type='struct _xsltStyleBasicExpressionItem'>
      <field name='select' type='const xmlChar *' info=' TODO: Change this to &quot;expression&quot;.'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' TODO: Change this to compExpr.'/>
    </struct>
    <typedef name='xsltStyleBasicExpressionItemPtr' file='xsltInternals' type='xsltStyleBasicExpressionItem *'/>
    <struct name='xsltStyleBasicItemVariable' file='xsltInternals' type='struct _xsltStyleBasicItemVariable'>
      <field name='select' type='const xmlChar *' info=''/>
      <field name='comp' type='xmlXPathCompExprPtr' info=''/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='has_name' type='int' info=''/>
      <field name='ns' type='const xmlChar *' info=''/>
      <field name='has_ns' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleBasicItemVariablePtr' file='xsltInternals' type='xsltStyleBasicItemVariable *'/>
    <typedef name='xsltStyleItemApplyImports' file='xsltInternals' type='xsltStyleBasicEmptyItem'/>
    <typedef name='xsltStyleItemApplyImportsPtr' file='xsltInternals' type='xsltStyleItemApplyImports *'/>
    <struct name='xsltStyleItemApplyTemplates' file='xsltInternals' type='struct _xsltStyleItemApplyTemplates'>
      <field name='mode' type='const xmlChar *' info=' apply-templates'/>
      <field name='modeURI' type='const xmlChar *' info=' apply-templates'/>
      <field name='select' type='const xmlChar *' info=' sort, copy-of, value-of, apply-templates'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression TODO: with-params'/>
    </struct>
    <typedef name='xsltStyleItemApplyTemplatesPtr' file='xsltInternals' type='xsltStyleItemApplyTemplates *'/>
    <struct name='xsltStyleItemAttribute' file='xsltInternals' type='struct _xsltStyleItemAttribute'>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='has_name' type='int' info=''/>
      <field name='ns' type='const xmlChar *' info=''/>
      <field name='nsPrefix' type='const xmlChar *' info=''/>
      <field name='has_ns' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemAttributePtr' file='xsltInternals' type='xsltStyleItemAttribute *'/>
    <struct name='xsltStyleItemCallTemplate' file='xsltInternals' type='struct _xsltStyleItemCallTemplate'>
      <field name='templ' type='xsltTemplatePtr' info=' call-template'/>
      <field name='name' type='const xmlChar *' info=' element, attribute, pi'/>
      <field name='has_name' type='int' info=' element, attribute, pi'/>
      <field name='ns' type='const xmlChar *' info=' element'/>
      <field name='has_ns' type='int' info=' element TODO: with-params'/>
    </struct>
    <typedef name='xsltStyleItemCallTemplatePtr' file='xsltInternals' type='xsltStyleItemCallTemplate *'/>
    <typedef name='xsltStyleItemChoose' file='xsltInternals' type='xsltStyleBasicEmptyItem'/>
    <typedef name='xsltStyleItemChoosePtr' file='xsltInternals' type='xsltStyleItemChoose *'/>
    <typedef name='xsltStyleItemComment' file='xsltInternals' type='xsltStyleBasicEmptyItem'/>
    <typedef name='xsltStyleItemCommentPtr' file='xsltInternals' type='xsltStyleItemComment *'/>
    <struct name='xsltStyleItemCopy' file='xsltInternals' type='struct _xsltStyleItemCopy'>
      <field name='use' type='const xmlChar *' info=' copy, element'/>
      <field name='has_use' type='int' info=' copy, element'/>
    </struct>
    <typedef name='xsltStyleItemCopyOf' file='xsltInternals' type='xsltStyleBasicExpressionItem'/>
    <typedef name='xsltStyleItemCopyOfPtr' file='xsltInternals' type='xsltStyleItemCopyOf *'/>
    <typedef name='xsltStyleItemCopyPtr' file='xsltInternals' type='xsltStyleItemCopy *'/>
    <struct name='xsltStyleItemDocument' file='xsltInternals' type='struct _xsltStyleItemDocument'>
      <field name='ver11' type='int' info=' assigned: in xsltDocumentComp;
read: nowhere;
TODO: Check if we need.'/>
      <field name='filename' type='const xmlChar *' info=' document URL'/>
      <field name='has_filename' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemDocumentPtr' file='xsltInternals' type='xsltStyleItemDocument *'/>
    <struct name='xsltStyleItemElement' file='xsltInternals' type='struct _xsltStyleItemElement'>
      <field name='use' type='const xmlChar *' info=''/>
      <field name='has_use' type='int' info=''/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='has_name' type='int' info=''/>
      <field name='ns' type='const xmlChar *' info=''/>
      <field name='nsPrefix' type='const xmlChar *' info=''/>
      <field name='has_ns' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemElementPtr' file='xsltInternals' type='xsltStyleItemElement *'/>
    <struct name='xsltStyleItemExtElement' file='xsltInternals' type='struct _xsltStyleItemExtElement'>
      <field name='item' type='xsltElemPreCompPtr' info=''/>
    </struct>
    <typedef name='xsltStyleItemExtElementPtr' file='xsltInternals' type='xsltStyleItemExtElement *'/>
    <typedef name='xsltStyleItemFallback' file='xsltInternals' type='xsltStyleBasicEmptyItem'/>
    <typedef name='xsltStyleItemFallbackPtr' file='xsltInternals' type='xsltStyleItemFallback *'/>
    <typedef name='xsltStyleItemForEach' file='xsltInternals' type='xsltStyleBasicExpressionItem'/>
    <typedef name='xsltStyleItemForEachPtr' file='xsltInternals' type='xsltStyleItemForEach *'/>
    <struct name='xsltStyleItemIf' file='xsltInternals' type='struct _xsltStyleItemIf'>
      <field name='test' type='const xmlChar *' info=' if'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression'/>
    </struct>
    <typedef name='xsltStyleItemIfPtr' file='xsltInternals' type='xsltStyleItemIf *'/>
    <struct name='xsltStyleItemInclude' file='xsltInternals' type='struct _xsltStyleItemInclude'>
      <field name='include' type='xsltDocumentPtr' info=''/>
    </struct>
    <typedef name='xsltStyleItemIncludePtr' file='xsltInternals' type='xsltStyleItemInclude *'/>
    <struct name='xsltStyleItemLRElementInfo' file='xsltInternals' type='struct _xsltStyleItemLRElementInfo'>
      <field name='effectiveNs' type='xsltEffectiveNsPtr' info=''/>
    </struct>
    <typedef name='xsltStyleItemLRElementInfoPtr' file='xsltInternals' type='xsltStyleItemLRElementInfo *'/>
    <struct name='xsltStyleItemMessage' file='xsltInternals' type='struct _xsltStyleItemMessage'>
      <field name='terminate' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemMessagePtr' file='xsltInternals' type='xsltStyleItemMessage *'/>
    <struct name='xsltStyleItemNumber' file='xsltInternals' type='struct _xsltStyleItemNumber'>
      <field name='numdata' type='xsltNumberData' info=' number'/>
    </struct>
    <typedef name='xsltStyleItemNumberPtr' file='xsltInternals' type='xsltStyleItemNumber *'/>
    <struct name='xsltStyleItemOtherwise' file='xsltInternals' type='struct _xsltStyleItemOtherwise'>
    </struct>
    <typedef name='xsltStyleItemOtherwisePtr' file='xsltInternals' type='xsltStyleItemOtherwise *'/>
    <struct name='xsltStyleItemPI' file='xsltInternals' type='struct _xsltStyleItemPI'>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='has_name' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemPIPtr' file='xsltInternals' type='xsltStyleItemPI *'/>
    <struct name='xsltStyleItemParam' file='xsltInternals' type='struct _xsltStyleItemParam'>
      <field name='select' type='const xmlChar *' info=''/>
      <field name='comp' type='xmlXPathCompExprPtr' info=''/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='has_name' type='int' info=''/>
      <field name='ns' type='const xmlChar *' info=''/>
      <field name='has_ns' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemParamPtr' file='xsltInternals' type='xsltStyleItemParam *'/>
    <struct name='xsltStyleItemSort' file='xsltInternals' type='struct _xsltStyleItemSort'>
      <field name='stype' type='const xmlChar *' info=' sort'/>
      <field name='has_stype' type='int' info=' sort'/>
      <field name='number' type='int' info=' sort'/>
      <field name='order' type='const xmlChar *' info=' sort'/>
      <field name='has_order' type='int' info=' sort'/>
      <field name='descending' type='int' info=' sort'/>
      <field name='lang' type='const xmlChar *' info=' sort'/>
      <field name='has_lang' type='int' info=' sort'/>
      <field name='locale' type='xsltLocale' info=' sort'/>
      <field name='case_order' type='const xmlChar *' info=' sort'/>
      <field name='lower_first' type='int' info=' sort'/>
      <field name='use' type='const xmlChar *' info=''/>
      <field name='has_use' type='int' info=''/>
      <field name='select' type='const xmlChar *' info=' sort, copy-of, value-of, apply-templates'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression'/>
    </struct>
    <typedef name='xsltStyleItemSortPtr' file='xsltInternals' type='xsltStyleItemSort *'/>
    <struct name='xsltStyleItemText' file='xsltInternals' type='struct _xsltStyleItemText'>
      <field name='noescape' type='int' info=' text'/>
    </struct>
    <typedef name='xsltStyleItemTextPtr' file='xsltInternals' type='xsltStyleItemText *'/>
    <struct name='xsltStyleItemUknown' file='xsltInternals' type='struct _xsltStyleItemUknown'>
    </struct>
    <typedef name='xsltStyleItemUknownPtr' file='xsltInternals' type='xsltStyleItemUknown *'/>
    <struct name='xsltStyleItemValueOf' file='xsltInternals' type='struct _xsltStyleItemValueOf'>
      <field name='select' type='const xmlChar *' info=''/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression'/>
      <field name='noescape' type='int' info=''/>
    </struct>
    <typedef name='xsltStyleItemValueOfPtr' file='xsltInternals' type='xsltStyleItemValueOf *'/>
    <typedef name='xsltStyleItemVariable' file='xsltInternals' type='xsltStyleBasicItemVariable'/>
    <typedef name='xsltStyleItemVariablePtr' file='xsltInternals' type='xsltStyleItemVariable *'/>
    <struct name='xsltStyleItemWhen' file='xsltInternals' type='struct _xsltStyleItemWhen'>
      <field name='test' type='const xmlChar *' info=''/>
      <field name='comp' type='xmlXPathCompExprPtr' info=''/>
    </struct>
    <typedef name='xsltStyleItemWhenPtr' file='xsltInternals' type='xsltStyleItemWhen *'/>
    <typedef name='xsltStyleItemWithParam' file='xsltInternals' type='xsltStyleBasicItemVariable'/>
    <typedef name='xsltStyleItemWithParamPtr' file='xsltInternals' type='xsltStyleItemWithParam *'/>
    <struct name='xsltStylePreComp' file='xsltInternals' type='struct _xsltStylePreComp'>
      <field name='next' type='xsltElemPreCompPtr' info=' chained list'/>
      <field name='type' type='xsltStyleType' info=' type of the element'/>
      <field name='func' type='xsltTransformFunction' info=' handling function'/>
      <field name='inst' type='xmlNodePtr' info='* Pre computed values.
*'/>
      <field name='stype' type='const xmlChar *' info=' sort'/>
      <field name='has_stype' type='int' info=' sort'/>
      <field name='number' type='int' info=' sort'/>
      <field name='order' type='const xmlChar *' info=' sort'/>
      <field name='has_order' type='int' info=' sort'/>
      <field name='descending' type='int' info=' sort'/>
      <field name='lang' type='const xmlChar *' info=' sort'/>
      <field name='has_lang' type='int' info=' sort'/>
      <field name='locale' type='xsltLocale' info=' sort'/>
      <field name='case_order' type='const xmlChar *' info=' sort'/>
      <field name='lower_first' type='int' info=' sort'/>
      <field name='use' type='const xmlChar *' info=' copy, element'/>
      <field name='has_use' type='int' info=' copy, element'/>
      <field name='noescape' type='int' info=' text'/>
      <field name='name' type='const xmlChar *' info=' element, attribute, pi'/>
      <field name='has_name' type='int' info=' element, attribute, pi'/>
      <field name='ns' type='const xmlChar *' info=' element'/>
      <field name='has_ns' type='int' info=' element'/>
      <field name='mode' type='const xmlChar *' info=' apply-templates'/>
      <field name='modeURI' type='const xmlChar *' info=' apply-templates'/>
      <field name='test' type='const xmlChar *' info=' if'/>
      <field name='templ' type='xsltTemplatePtr' info=' call-template'/>
      <field name='select' type='const xmlChar *' info=' sort, copy-of, value-of, apply-templates'/>
      <field name='ver11' type='int' info=' document'/>
      <field name='filename' type='const xmlChar *' info=' document URL'/>
      <field name='has_filename' type='int' info=' document'/>
      <field name='numdata' type='xsltNumberData' info=' number'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression'/>
      <field name='nsList' type='xmlNsPtr *' info=' the namespaces in scope'/>
      <field name='nsNr' type='int' info=' the number of namespaces in scope'/>
    </struct>
    <typedef name='xsltStylePreCompPtr' file='xsltInternals' type='xsltStylePreComp *'/>
    <typedef name='xsltStyleType' file='xsltInternals' type='enum'/>
    <struct name='xsltStylesheet' file='xsltInternals' type='struct _xsltStylesheet'>
      <field name='parent' type='struct _xsltStylesheet *' info=''/>
      <field name='next' type='struct _xsltStylesheet *' info=''/>
      <field name='imports' type='struct _xsltStylesheet *' info=''/>
      <field name='docList' type='xsltDocumentPtr' info='* General data on the style sheet document.
*'/>
      <field name='doc' type='xmlDocPtr' info=' the parsed XML stylesheet'/>
      <field name='stripSpaces' type='xmlHashTablePtr' info=' the hash table of the strip-space and
preserve space elements'/>
      <field name='stripAll' type='int' info=' strip-space * (1) preserve-space * (-1)'/>
      <field name='cdataSection' type='xmlHashTablePtr' info='* Global variable or parameters.
*'/>
      <field name='variables' type='xsltStackElemPtr' info='* Template descriptions.
*'/>
      <field name='templates' type='xsltTemplatePtr' info=' the ordered list of templates'/>
      <field name='templatesHash' type='xmlHashTablePtr' info=' hash table or wherever compiled
templates information is stored'/>
      <field name='rootMatch' type='struct _xsltCompMatch *' info=' template based on /'/>
      <field name='keyMatch' type='struct _xsltCompMatch *' info=' template based on key()'/>
      <field name='elemMatch' type='struct _xsltCompMatch *' info=' template based on *'/>
      <field name='attrMatch' type='struct _xsltCompMatch *' info=' template based on @*'/>
      <field name='parentMatch' type='struct _xsltCompMatch *' info=' template based on ..'/>
      <field name='textMatch' type='struct _xsltCompMatch *' info=' template based on text()'/>
      <field name='piMatch' type='struct _xsltCompMatch *' info=' template based on
processing-instruction()'/>
      <field name='commentMatch' type='struct _xsltCompMatch *' info='* Namespace aliases.
* NOTE: Not used in the refactored code.
*'/>
      <field name='nsAliases' type='xmlHashTablePtr' info='* Attribute sets.
*'/>
      <field name='attributeSets' type='xmlHashTablePtr' info='* Namespaces.
* TODO: Eliminate this.
*'/>
      <field name='nsHash' type='xmlHashTablePtr' info=' the set of namespaces in use:
ATTENTION: This is used for
execution of XPath expressions; unfortunately
it restricts the stylesheet to have distinct
prefixes.
TODO: We need to get rid of this.
*'/>
      <field name='nsDefs' type='void *' info='* Key definitions.
*'/>
      <field name='keys' type='void *' info='* Output related stuff.
*'/>
      <field name='method' type='xmlChar *' info=' the output method'/>
      <field name='methodURI' type='xmlChar *' info=' associated namespace if any'/>
      <field name='version' type='xmlChar *' info=' version string'/>
      <field name='encoding' type='xmlChar *' info=' encoding string'/>
      <field name='omitXmlDeclaration' type='int' info='* Number formatting.
*'/>
      <field name='decimalFormat' type='xsltDecimalFormatPtr' info=''/>
      <field name='standalone' type='int' info=' standalone = &quot;yes&quot; | &quot;no&quot;'/>
      <field name='doctypePublic' type='xmlChar *' info=' doctype-public string'/>
      <field name='doctypeSystem' type='xmlChar *' info=' doctype-system string'/>
      <field name='indent' type='int' info=' should output being indented'/>
      <field name='mediaType' type='xmlChar *' info='* Precomputed blocks.
*'/>
      <field name='preComps' type='xsltElemPreCompPtr' info=' list of precomputed blocks'/>
      <field name='warnings' type='int' info=' number of warnings found at compilation'/>
      <field name='errors' type='int' info=' number of errors found at compilation'/>
      <field name='exclPrefix' type='xmlChar *' info=' last excluded prefixes'/>
      <field name='exclPrefixTab' type='xmlChar **' info=' array of excluded prefixes'/>
      <field name='exclPrefixNr' type='int' info=' number of excluded prefixes in scope'/>
      <field name='exclPrefixMax' type='int' info=' size of the array'/>
      <field name='_private' type='void *' info='* Extensions.
*'/>
      <field name='extInfos' type='xmlHashTablePtr' info=' the extension data'/>
      <field name='extrasNr' type='int' info='* For keeping track of nested includes
*'/>
      <field name='includes' type='xsltDocumentPtr' info='* dictionary: shared between stylesheet, context and documents.
*'/>
      <field name='dict' type='xmlDictPtr' info='* precompiled attribute value templates.
*'/>
      <field name='attVTs' type='void *' info='* if namespace-alias has an alias for the default stylesheet prefix
* NOTE: Not used in the refactored code.
*'/>
      <field name='defaultAlias' type='const xmlChar *' info='* bypass pre-processing (already done) (used in imports)
*'/>
      <field name='nopreproc' type='int' info='* all document text strings were internalized
*'/>
      <field name='internalized' type='int' info='* Literal Result Element as Stylesheet c.f. section 2.3
*'/>
      <field name='literal_result' type='int' info='* The principal stylesheet
*'/>
      <field name='principal' type='xsltStylesheetPtr' info='* Compilation context used during compile-time.
*'/>
      <field name='compCtxt' type='xsltCompilerCtxtPtr' info=' TODO: Change this to (void *).'/>
      <field name='principalData' type='xsltPrincipalStylesheetDataPtr' info='* Forwards-compatible processing
*'/>
      <field name='forwards_compatible' type='int' info=''/>
      <field name='namedTemplates' type='xmlHashTablePtr' info=' hash table of named templates'/>
      <field name='xpathCtxt' type='xmlXPathContextPtr' info=''/>
    </struct>
    <typedef name='xsltStylesheetPtr' file='xsltInternals' type='xsltStylesheet *'/>
    <struct name='xsltTemplate' file='xsltInternals' type='struct _xsltTemplate'>
      <field name='next' type='struct _xsltTemplate *' info=' chained list sorted by priority'/>
      <field name='style' type='struct _xsltStylesheet *' info=' the containing stylesheet'/>
      <field name='match' type='xmlChar *' info=' the matching string'/>
      <field name='priority' type='float' info=' as given from the stylesheet, not computed'/>
      <field name='name' type='const xmlChar *' info=' the local part of the name QName'/>
      <field name='nameURI' type='const xmlChar *' info=' the URI part of the name QName'/>
      <field name='mode' type='const xmlChar *' info=' the local part of the mode QName'/>
      <field name='modeURI' type='const xmlChar *' info=' the URI part of the mode QName'/>
      <field name='content' type='xmlNodePtr' info=' the template replacement value'/>
      <field name='elem' type='xmlNodePtr' info='* TODO: @inheritedNsNr and @inheritedNs won&apos;t be used in the
*  refactored code.
*'/>
      <field name='inheritedNsNr' type='int' info=' number of inherited namespaces'/>
      <field name='inheritedNs' type='xmlNsPtr *' info=' inherited non-excluded namespaces Profiling information'/>
      <field name='nbCalls' type='int' info=' the number of time the template was called'/>
      <field name='time' type='unsigned long' info=' the time spent in this template'/>
      <field name='params' type='void *' info=' xsl:param instructions'/>
      <field name='templNr' type='int' info=' Nb of templates in the stack'/>
      <field name='templMax' type='int' info=' Size of the templtes stack'/>
      <field name='templCalledTab' type='xsltTemplatePtr *' info=' templates called'/>
      <field name='templCountTab' type='int *' info=' .. and how often Conflict resolution'/>
      <field name='position' type='int' info=''/>
    </struct>
    <typedef name='xsltTemplatePtr' file='xsltInternals' type='xsltTemplate *'/>
    <struct name='xsltTransformCache' file='xsltInternals' type='struct _xsltTransformCache'>
      <field name='RVT' type='xmlDocPtr' info=''/>
      <field name='nbRVT' type='int' info=''/>
      <field name='stackItems' type='xsltStackElemPtr' info=''/>
      <field name='nbStackItems' type='int' info=''/>
      <field name='dbgCachedRVTs' type='int' info=''/>
      <field name='dbgReusedRVTs' type='int' info=''/>
      <field name='dbgCachedVars' type='int' info=''/>
      <field name='dbgReusedVars' type='int' info=''/>
    </struct>
    <typedef name='xsltTransformCachePtr' file='xsltInternals' type='xsltTransformCache *'/>
    <struct name='xsltTransformContext' file='xsltInternals' type='struct _xsltTransformContext'>
      <field name='style' type='xsltStylesheetPtr' info=' the stylesheet used'/>
      <field name='type' type='xsltOutputType' info=' the type of output'/>
      <field name='templ' type='xsltTemplatePtr' info=' the current template'/>
      <field name='templNr' type='int' info=' Nb of templates in the stack'/>
      <field name='templMax' type='int' info=' Size of the templtes stack'/>
      <field name='templTab' type='xsltTemplatePtr *' info=' the template stack'/>
      <field name='vars' type='xsltStackElemPtr' info=' the current variable list'/>
      <field name='varsNr' type='int' info=' Nb of variable list in the stack'/>
      <field name='varsMax' type='int' info=' Size of the variable list stack'/>
      <field name='varsTab' type='xsltStackElemPtr *' info=' the variable list stack'/>
      <field name='varsBase' type='int' info='* Extensions
*'/>
      <field name='extFunctions' type='xmlHashTablePtr' info=' the extension functions'/>
      <field name='extElements' type='xmlHashTablePtr' info=' the extension elements'/>
      <field name='extInfos' type='xmlHashTablePtr' info=' the extension data'/>
      <field name='mode' type='const xmlChar *' info=' the current mode'/>
      <field name='modeURI' type='const xmlChar *' info=' the current mode URI'/>
      <field name='docList' type='xsltDocumentPtr' info=' the document list'/>
      <field name='document' type='xsltDocumentPtr' info=' the current source document; can be NULL if an RTF'/>
      <field name='node' type='xmlNodePtr' info=' the current node being processed'/>
      <field name='nodeList' type='xmlNodeSetPtr' info=' the current node list xmlNodePtr current;			the node'/>
      <field name='output' type='xmlDocPtr' info=' the resulting document'/>
      <field name='insert' type='xmlNodePtr' info=' the insertion node'/>
      <field name='xpathCtxt' type='xmlXPathContextPtr' info=' the XPath context'/>
      <field name='state' type='xsltTransformState' info='* Global variables
*'/>
      <field name='globalVars' type='xmlHashTablePtr' info=' the global variables and params'/>
      <field name='inst' type='xmlNodePtr' info=' the instruction in the stylesheet'/>
      <field name='xinclude' type='int' info=' should XInclude be processed'/>
      <field name='outputFile' type='const char *' info=' the output URI if known'/>
      <field name='profile' type='int' info=' is this run profiled'/>
      <field name='prof' type='long' info=' the current profiled value'/>
      <field name='profNr' type='int' info=' Nb of templates in the stack'/>
      <field name='profMax' type='int' info=' Size of the templtaes stack'/>
      <field name='profTab' type='long *' info=' the profile template stack'/>
      <field name='_private' type='void *' info=' user defined data'/>
      <field name='extrasNr' type='int' info=' the number of extras used'/>
      <field name='extrasMax' type='int' info=' the number of extras allocated'/>
      <field name='extras' type='xsltRuntimeExtraPtr' info=' extra per runtime information'/>
      <field name='styleList' type='xsltDocumentPtr' info=' the stylesheet docs list'/>
      <field name='sec' type='void *' info=' the security preferences if any'/>
      <field name='error' type='xmlGenericErrorFunc' info=' a specific error handler'/>
      <field name='errctx' type='void *' info=' context for the error handler'/>
      <field name='sortfunc' type='xsltSortFunc' info='* handling of temporary Result Value Tree
* (XSLT 1.0 term: &quot;Result Tree Fragment&quot;)
*'/>
      <field name='tmpRVT' type='xmlDocPtr' info=' list of RVT without persistance'/>
      <field name='persistRVT' type='xmlDocPtr' info=' list of persistant RVTs'/>
      <field name='ctxtflags' type='int' info='* Speed optimization when coalescing text nodes
*'/>
      <field name='lasttext' type='const xmlChar *' info=' last text node content'/>
      <field name='lasttsize' type='int' info=' last text node size'/>
      <field name='lasttuse' type='int' info='* Per Context Debugging
*'/>
      <field name='debugStatus' type='int' info=' the context level debug status'/>
      <field name='traceCode' type='unsigned long *' info=' pointer to the variable holding the mask'/>
      <field name='parserOptions' type='int' info='* dictionary: shared between stylesheet, context and documents.
*'/>
      <field name='dict' type='xmlDictPtr' info=''/>
      <field name='tmpDoc' type='xmlDocPtr' info='* all document text strings are internalized
*'/>
      <field name='internalized' type='int' info=''/>
      <field name='nbKeys' type='int' info=''/>
      <field name='hasTemplKeyPatterns' type='int' info=''/>
      <field name='currentTemplateRule' type='xsltTemplatePtr' info=' the Current Template Rule'/>
      <field name='initialContextNode' type='xmlNodePtr' info=''/>
      <field name='initialContextDoc' type='xmlDocPtr' info=''/>
      <field name='cache' type='xsltTransformCachePtr' info=''/>
      <field name='contextVariable' type='void *' info=' the current variable item'/>
      <field name='localRVT' type='xmlDocPtr' info=' list of local tree fragments; will be freed when
the instruction which created the fragment
exits'/>
      <field name='localRVTBase' type='xmlDocPtr' info=' Obsolete'/>
      <field name='keyInitLevel' type='int' info=' Needed to catch recursive keys issues'/>
      <field name='depth' type='int' info=' Needed to catch recursions'/>
      <field name='maxTemplateDepth' type='int' info=''/>
      <field name='maxTemplateVars' type='int' info=''/>
      <field name='opLimit' type='unsigned long' info=''/>
      <field name='opCount' type='unsigned long' info=''/>
    </struct>
    <typedef name='xsltTransformContextPtr' file='xsltInternals' type='xsltTransformContext *'/>
    <typedef name='xsltTransformState' file='xsltInternals' type='enum'/>
    <struct name='xsltVarInfo' file='xsltInternals' type='struct _xsltVarInfo'>
      <field name='next' type='xsltVarInfoPtr' info=' next in the list'/>
      <field name='prev' type='xsltVarInfoPtr' info=''/>
      <field name='depth' type='int' info=' the depth in the tree'/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='nsName' type='const xmlChar *' info=''/>
    </struct>
    <typedef name='xsltVarInfoPtr' file='xsltInternals' type='xsltVarInfo *'/>
    <variable name='xslDebugStatus' file='xsltutils' type='int'/>
    <variable name='xsltConstNamespaceNameXSLT' file='xsltInternals' type='const xmlChar *'/>
    <variable name='xsltDocDefaultLoader' file='documents' type='xsltDocLoaderFunc'/>
    <variable name='xsltEngineVersion' file='xslt' type='const char *'/>
    <variable name='xsltExtMarker' file='preproc' type='const xmlChar *'/>
    <variable name='xsltGenericDebug' file='xsltutils' type='xmlGenericErrorFunc'/>
    <variable name='xsltGenericDebugContext' file='xsltutils' type='void *'/>
    <variable name='xsltGenericError' file='xsltutils' type='xmlGenericErrorFunc'/>
    <variable name='xsltGenericErrorContext' file='xsltutils' type='void *'/>
    <variable name='xsltLibxmlVersion' file='xslt' type='const int'/>
    <variable name='xsltLibxsltVersion' file='xslt' type='const int'/>
    <variable name='xsltMaxDepth' file='xslt' type='int'/>
    <variable name='xsltMaxVars' file='xslt' type='int'/>
    <variable name='xsltXSLTAttrMarker' file='xsltInternals' type='const xmlChar *'/>
    <function name='xslAddCall' file='xsltutils'>
      <info>Add template &quot;call&quot; to call stack</info>
      <return type='int' info=': 1 on sucess 0 otherwise an error may be printed if WITH_XSLT_DEBUG_BREAKPOINTS is defined'/>
      <arg name='templ' type='xsltTemplatePtr' info='current template being applied'/>
      <arg name='source' type='xmlNodePtr' info='the source node being processed'/>
    </function>
    <function name='xslDropCall' file='xsltutils'>
      <info>Drop the topmost item off the call stack</info>
      <return type='void'/>
    </function>
    <function name='xslHandleDebugger' file='transform'>
      <info>If either cur or node are a breakpoint, or xslDebugStatus in state where debugging must occcur at this time then transfer control to the xslDebugBreak function</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='source node being executed'/>
      <arg name='node' type='xmlNodePtr' info='data node being processed'/>
      <arg name='templ' type='xsltTemplatePtr' info='temlate that applies to node'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the xslt transform context'/>
    </function>
    <functype name='xsltAddCallCallback' file='xsltutils'>
      <info></info>
      <return type='int' info=''/>
      <arg name='templ' type='xsltTemplatePtr' info=''/>
      <arg name='source' type='xmlNodePtr' info=''/>
    </functype>
    <function name='xsltAddKey' file='keys'>
      <info>add a key definition to a stylesheet</info>
      <return type='int' info='0 in case of success, and -1 in case of failure.'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL'/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL'/>
      <arg name='match' type='const xmlChar *' info='the match value'/>
      <arg name='use' type='const xmlChar *' info='the use value'/>
      <arg name='inst' type='xmlNodePtr' info='the key instruction'/>
    </function>
    <function name='xsltAddStackElemList' file='variables'>
      <info>Push an element list onto the stack.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='xn XSLT transformation context'/>
      <arg name='elems' type='xsltStackElemPtr' info='a stack element list'/>
    </function>
    <function name='xsltAddTemplate' file='pattern'>
      <info>Register the XSLT pattern associated to @cur</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='cur' type='xsltTemplatePtr' info='an XSLT template'/>
      <arg name='mode' type='const xmlChar *' info='the mode name or NULL'/>
      <arg name='modeURI' type='const xmlChar *' info='the mode URI or NULL'/>
    </function>
    <function name='xsltAllocateExtra' file='xsltInternals'>
      <info>Allocate an extra runtime information slot statically while compiling the stylesheet and return its number</info>
      <return type='int' info='the number of the slot'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltAllocateExtraCtxt' file='xsltInternals'>
      <info>Allocate an extra runtime information slot at run-time and return its number This make sure there is a slot ready in the transformation context</info>
      <return type='int' info='the number of the slot'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltApplyAttributeSet' file='attributes'>
      <info>Apply the xsl:use-attribute-sets. If @attrSets is NULL, then @inst will be used to exctract this value. If both, @attrSets and @inst, are NULL, then this will do nothing.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the attribute node &quot;xsl:use-attribute-sets&quot;'/>
      <arg name='attrSets' type='const xmlChar *' info='the list of QNames of the attribute-sets to be applied'/>
    </function>
    <function name='xsltApplyImports' file='transform'>
      <info>Process the XSLT apply-imports element.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the current node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the element node of the XSLT &apos;apply-imports&apos; instruction'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the compiled instruction'/>
    </function>
    <function name='xsltApplyOneTemplate' file='transform'>
      <info>Processes a sequence constructor on the current node in the source tree.  @params are the already computed variable stack items; this function pushes them on the variable stack, and pops them before exiting; it&apos;s left to the caller to free or reuse @params afterwards. The initial states of the variable stack will always be restored before this function exits. NOTE that this does *not* initiate a new distinct variable scope; i.e. variables already on the stack are visible to the process. The caller&apos;s side needs to start a new variable scope if needed (e.g. in exsl:function).  @templ is obsolete and not used anymore (e.g. &lt;exslt:function&gt; does not provide a @templ); a non-NULL @templ might raise an error in the future.  BIG NOTE: This function is not intended to process the content of an xsl:template; it does not expect xsl:param instructions in @list and will report errors if found.  Called by: - xsltEvalVariable() (variables.c) - exsltFuncFunctionFunction() (libexsl/functions.c)</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='list' type='xmlNodePtr' info='the nodes of a sequence constructor'/>
      <arg name='templ' type='xsltTemplatePtr' info='not used'/>
      <arg name='params' type='xsltStackElemPtr' info='a set of parameters (xsl:param) or NULL'/>
    </function>
    <function name='xsltApplyStripSpaces' file='transform'>
      <info>Strip the unwanted ignorable spaces from the input tree</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the root of the XML tree'/>
    </function>
    <function name='xsltApplyStylesheet' file='transform'>
      <info>Apply the stylesheet to the document NOTE: This may lead to a non-wellformed output XML wise !</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
    </function>
    <function name='xsltApplyStylesheetUser' file='transform'>
      <info>Apply the stylesheet to the document and allow the user to provide its own transformation context.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated array of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the targetted output'/>
      <arg name='profile' type='FILE *' info='profile FILE * output or NULL'/>
      <arg name='userCtxt' type='xsltTransformContextPtr' info='user provided transform context'/>
    </function>
    <function name='xsltApplyTemplates' file='transform'>
      <info>Processes the XSLT &apos;apply-templates&apos; instruction on the current node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the &apos;current node&apos; in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the element node of an XSLT &apos;apply-templates&apos; instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='the compiled instruction'/>
    </function>
    <function name='xsltAttrListTemplateProcess' file='templates'>
      <info>Processes all attributes of a Literal Result Element. Attribute references are applied via xsl:use-attribute-set attributes. Copies all non XSLT-attributes over to the @target element and evaluates Attribute Value Templates.  Called by xsltApplySequenceConstructor() (transform.c).</info>
      <return type='xmlAttrPtr' info='a new list of attribute nodes, or NULL in case of error. (Don&apos;t assign the result to @target-&gt;properties; if the result is NULL, you&apos;ll get memory leaks, since the attributes will be disattached.)'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted'/>
      <arg name='attrs' type='xmlAttrPtr' info='the first attribute'/>
    </function>
    <function name='xsltAttrTemplateProcess' file='templates'>
      <info>Process one attribute of a Literal Result Element (in the stylesheet). Evaluates Attribute Value Templates and copies the attribute over to the result element. This does *not* process attribute sets (xsl:use-attribute-set).</info>
      <return type='xmlAttrPtr' info='the generated attribute node.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='target' type='xmlNodePtr' info='the element where the attribute will be grafted'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute node of a literal result element'/>
    </function>
    <function name='xsltAttrTemplateValueProcess' file='templates'>
      <info>Process the given node and return the new string value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='str' type='const xmlChar *' info='the attribute template node value'/>
    </function>
    <function name='xsltAttrTemplateValueProcessNode' file='templates'>
      <info>Process the given string, allowing to pass a namespace mapping context and return the new string value.  Called by: - xsltAttrTemplateValueProcess() (templates.c) - xsltEvalAttrValueTemplate() (templates.c)  QUESTION: Why is this function public? It is not used outside of templates.c.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='str' type='const xmlChar *' info='the attribute template node value'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction (or LRE) in the stylesheet holding the attribute with an AVT'/>
    </function>
    <function name='xsltAttribute' file='transform'>
      <info>Process the xslt attribute node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the current node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the xsl:attribute element'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCalibrateAdjust' file='xsltutils'>
      <info>Used for to correct the calibration for xsltTimestamp()</info>
      <return type='void'/>
      <arg name='delta' type='long' info='a negative dealy value found'/>
    </function>
    <function name='xsltCallTemplate' file='transform'>
      <info>Processes the XSLT call-template instruction on the source node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the &quot;current node&quot; in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the XSLT &apos;call-template&apos; instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='the compiled information of the instruction'/>
    </function>
    <function name='xsltCheckExtPrefix' file='extensions'>
      <info>Check if the given prefix is one of the declared extensions. This is intended to be called only at compile-time. Called by: xsltGetInheritedNsList() (xslt.c) xsltParseTemplateContent (xslt.c)</info>
      <return type='int' info='1 if this is an extension, 0 otherwise'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the namespace prefix (possibly NULL)'/>
    </function>
    <function name='xsltCheckExtURI' file='extensions'>
      <info>Check if the given prefix is one of the declared extensions. This is intended to be called only at compile-time. Called by: xsltPrecomputeStylesheet() (xslt.c) xsltParseTemplateContent (xslt.c)</info>
      <return type='int' info='1 if this is an extension, 0 otherwise'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI (possibly NULL)'/>
    </function>
    <function name='xsltCheckRead' file='security'>
      <info>Check if the resource is allowed to be read</info>
      <return type='int' info='1 if read is allowed, 0 if not and -1 in case or error.'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security options'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URL' type='const xmlChar *' info='the resource to be read'/>
    </function>
    <function name='xsltCheckWrite' file='security'>
      <info>Check if the resource is allowed to be written, if necessary makes some preliminary work like creating directories</info>
      <return type='int' info='1 if write is allowed, 0 if not and -1 in case or error.'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security options'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URL' type='const xmlChar *' info='the resource to be written'/>
    </function>
    <function name='xsltChoose' file='transform'>
      <info>Processes the xsl:choose instruction on the source node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the current node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the xsl:choose instruction'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='compiled information of the instruction'/>
    </function>
    <function name='xsltCleanupGlobals' file='xslt'>
      <info>Unregister all global variables set up by the XSLT library</info>
      <return type='void'/>
    </function>
    <function name='xsltCleanupTemplates' file='pattern'>
      <info>Cleanup the state of the templates used by the stylesheet and the ones it imports.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltComment' file='transform'>
      <info>Process the xslt comment node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt comment node'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCompMatchClearCache' file='pattern'>
      <info>Clear pattern match cache.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='comp' type='xsltCompMatchPtr' info='the precompiled pattern list'/>
    </function>
    <function name='xsltCompileAttr' file='xsltInternals'>
      <info>Precompile an attribute in a stylesheet, basically it checks if it is an attribute value template, and if yes, establish some structures needed to process it at transformation time.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='a XSLT process context'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute coming from the stylesheet.'/>
    </function>
    <function name='xsltCompilePattern' file='pattern'>
      <info>Compile the XSLT pattern and generates a list of precompiled form suitable for fast matching.  [1] Pattern ::= LocationPathPattern | Pattern &apos;|&apos; LocationPathPattern</info>
      <return type='xsltCompMatchPtr' info='the generated pattern list or NULL in case of failure'/>
      <arg name='pattern' type='const xmlChar *' info='an XSLT pattern'/>
      <arg name='doc' type='xmlDocPtr' info='the containing document'/>
      <arg name='node' type='xmlNodePtr' info='the containing element'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='runtime' type='xsltTransformContextPtr' info='the transformation context, if done at run-time'/>
    </function>
    <function name='xsltComputeSortResult' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the array of nodes.</info>
      <return type='xmlXPathObjectPtr *' info='a ordered XPath nodeset or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sort' type='xmlNodePtr' info='node list'/>
    </function>
    <function name='xsltCopy' file='transform'>
      <info>Execute the XSLT-copy instruction on the source node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the element node of the XSLT-copy instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='computed information of the XSLT-copy instruction'/>
    </function>
    <function name='xsltCopyNamespace' file='namespaces'>
      <info>Copies a namespace node (declaration). If @elem is not NULL, then the new namespace will be declared on @elem.</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of an error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='elem' type='xmlNodePtr' info='the target element node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace node'/>
    </function>
    <function name='xsltCopyNamespaceList' file='namespaces'>
      <info>Do a copy of an namespace list. If @node is non-NULL the new namespaces are added automatically. This handles namespaces aliases. This function is intended only for *internal* use at transformation-time for copying ns-declarations of Literal Result Elements.  Called by: xsltCopyTreeInternal() (transform.c) xsltShallowCopyElem() (transform.c)  REVISIT: This function won&apos;t be used in the refactored code.</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the target node'/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace'/>
    </function>
    <function name='xsltCopyOf' file='transform'>
      <info>Process the XSLT copy-of instruction.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the current node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the element node of the XSLT copy-of instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information of the XSLT copy-of instruction'/>
    </function>
    <function name='xsltCopyTextString' file='transform'>
      <info>Adds @string to a newly created or an existent text node child of @target.</info>
      <return type='xmlNodePtr' info='the text node, where the text content of @cur is copied to. NULL in case of API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='target' type='xmlNodePtr' info='the element where the text will be attached'/>
      <arg name='string' type='const xmlChar *' info='the text string'/>
      <arg name='noescape' type='int' info='should disable-escaping be activated for this text node.'/>
    </function>
    <function name='xsltCreateRVT' file='xsltInternals'>
      <info>Creates a Result Value Tree (the XSLT 1.0 term for this is &quot;Result Tree Fragment&quot;)</info>
      <return type='xmlDocPtr' info='the result value tree or NULL in case of API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltDebug' file='extra'>
      <info>Process an debug node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltDebugDumpExtensions' file='extensions'>
      <info>Dumps a list of the registered XSLT extension functions and elements</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output, if NULL stdout is used'/>
    </function>
    <function name='xsltDebugGetDefaultTrace' file='xsltutils'>
      <info>Get the current default debug tracing level mask</info>
      <return type='xsltDebugTraceCodes' info='the current default debug tracing level mask'/>
    </function>
    <function name='xsltDebugSetDefaultTrace' file='xsltutils'>
      <info>Set the default debug tracing level mask</info>
      <return type='void'/>
      <arg name='val' type='xsltDebugTraceCodes' info='tracing level mask'/>
    </function>
    <function name='xsltDecimalFormatGetByName' file='xsltInternals'>
      <info>Find decimal-format by name</info>
      <return type='xsltDecimalFormatPtr' info='the xsltDecimalFormatPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='name' type='xmlChar *' info='the decimal-format name to find'/>
    </function>
    <function name='xsltDecimalFormatGetByQName' file='xsltInternals'>
      <info>Find decimal-format by QName</info>
      <return type='xsltDecimalFormatPtr' info='the xsltDecimalFormatPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='nsUri' type='const xmlChar *' info='the namespace URI of the QName'/>
      <arg name='name' type='const xmlChar *' info='the local part of the QName'/>
    </function>
    <function name='xsltDefaultSortFunction' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the arry of nodes.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sorts' type='xmlNodePtr *' info='array of sort nodes'/>
      <arg name='nbsorts' type='int' info='the number of sorts in the array'/>
    </function>
    <function name='xsltDoSortFunction' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the arry of nodes. This is a wrapper function, the actual function used is specified using xsltSetCtxtSortFunc() to set the context specific sort function, or xsltSetSortFunc() to set the global sort function. If a sort function is set on the context, this will get called. Otherwise the global sort function is called.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sorts' type='xmlNodePtr *' info='array of sort nodes'/>
      <arg name='nbsorts' type='int' info='the number of sorts in the array'/>
    </function>
    <functype name='xsltDocLoaderFunc' file='documents'>
      <info>An xsltDocLoaderFunc is a signature for a function which can be registered to load document not provided by the compilation or transformation API themselve, for example when an xsl:import, xsl:include is found at compilation time or when a document() call is made at runtime.</info>
      <return type='xmlDocPtr' info='the pointer to the document (which will be modified and freed by the engine later), or NULL in case of error.'/>
      <arg name='URI' type='const xmlChar *' info='the URI of the document to load'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionary to use when parsing that document'/>
      <arg name='options' type='int' info='parsing options, a set of xmlParserOption'/>
      <arg name='ctxt' type='void *' info='the context, either a stylesheet or a transformation context'/>
      <arg name='type' type='xsltLoadType' info='the xsltLoadType indicating the kind of loading required'/>
    </functype>
    <function name='xsltDocumentComp' file='preproc'>
      <info>Pre process an XSLT-1.1 document element</info>
      <return type='xsltElemPreCompPtr' info='a precompiled data structure for the element'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='function' type='xsltTransformFunction' info='unused'/>
    </function>
    <function name='xsltDocumentElem' file='transform'>
      <info>Process an EXSLT/XSLT-1.1 document element</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltDocumentFunction' file='functions'>
      <info>Implement the document() XSLT function node-set document(object, node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltDocumentSortFunction' file='xsltutils'>
      <info>reorder the current node list @list accordingly to the document order This function is slow, obsolete and should not be used anymore.</info>
      <return type='void'/>
      <arg name='list' type='xmlNodeSetPtr' info='the node set'/>
    </function>
    <functype name='xsltDropCallCallback' file='xsltutils'>
      <info></info>
      <return type='void'/>
    </functype>
    <functype name='xsltElemPreCompDeallocator' file='xsltInternals'>
      <info>Deallocates an #xsltElemPreComp structure.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the #xsltElemPreComp to free up'/>
    </functype>
    <function name='xsltElement' file='transform'>
      <info>Process the xslt element node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt element node'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltElementAvailableFunction' file='functions'>
      <info>Implement the element-available() XSLT function boolean element-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltEvalAVT' file='xsltInternals'>
      <info>Process the given AVT, and return the new string value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='avt' type='void *' info='the prevompiled attribute value template info'/>
      <arg name='node' type='xmlNodePtr' info='the node hosting the attribute'/>
    </function>
    <function name='xsltEvalAttrValueTemplate' file='templates'>
      <info>Evaluate a attribute value template, i.e. the attribute value can contain expressions contained in curly braces ({}) and those are substituted by they computed value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction (or LRE) in the stylesheet holding the attribute with an AVT'/>
      <arg name='name' type='const xmlChar *' info='the attribute QName'/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI'/>
    </function>
    <function name='xsltEvalGlobalVariables' file='variables'>
      <info>Evaluates all global variables and parameters of a stylesheet. For internal use only. This is called at start of a transformation.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
    </function>
    <function name='xsltEvalOneUserParam' file='variables'>
      <info>This is normally called from xsltEvalUserParams to process a single parameter from a list of parameters.  The @value is evaluated as an XPath expression and the result is stored in the context&apos;s global variable/parameter hash table.  To have a parameter treated literally (not as an XPath expression) use xsltQuoteUserParams (or xsltQuoteOneUserParam).  For more details see description of xsltProcessOneUserParamInternal.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='a null terminated string giving the name of the parameter'/>
      <arg name='value' type='const xmlChar *' info='a null terminated string giving the XPath expression to be evaluated'/>
    </function>
    <function name='xsltEvalStaticAttrValueTemplate' file='templates'>
      <info>Check if an attribute value template has a static value, i.e. the attribute value does not contain expressions contained in curly braces ({})</info>
      <return type='const xmlChar *' info='the static string value or NULL, must be deallocated by the caller.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction (or LRE) in the stylesheet holding the attribute with an AVT'/>
      <arg name='name' type='const xmlChar *' info='the attribute Name'/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI'/>
      <arg name='found' type='int *' info='indicator whether the attribute is present'/>
    </function>
    <function name='xsltEvalTemplateString' file='templates'>
      <info>Processes the sequence constructor of the given instruction on @contextNode and converts the resulting tree to a string. This is needed by e.g. xsl:comment and xsl:processing-instruction.</info>
      <return type='xmlChar *' info='the computed string value or NULL; it&apos;s up to the caller to free the result.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the current node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the XSLT instruction (xsl:comment, xsl:processing-instruction)'/>
    </function>
    <function name='xsltEvalUserParams' file='variables'>
      <info>Evaluate the global variables of a stylesheet. This needs to be done on parsed stylesheets before starting to apply transformations. Each of the parameters is evaluated as an XPath expression and stored in the global variables/parameter hash table.  If you want your parameter used literally, use xsltQuoteUserParams.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='params' type='const char **' info='a NULL terminated array of parameters name/value tuples'/>
    </function>
    <function name='xsltEvalXPathPredicate' file='templates'>
      <info>Process the expression using XPath and evaluate the result as an XPath predicate</info>
      <return type='int' info='1 is the predicate was true, 0 otherwise'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the XPath compiled expression'/>
      <arg name='nsList' type='xmlNsPtr *' info='the namespaces in scope'/>
      <arg name='nsNr' type='int' info='the number of namespaces in scope'/>
    </function>
    <function name='xsltEvalXPathString' file='templates'>
      <info>Process the expression using XPath and get a string</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
    </function>
    <function name='xsltEvalXPathStringNs' file='templates'>
      <info>Process the expression using XPath, allowing to pass a namespace mapping context and get a string</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
      <arg name='nsNr' type='int' info='the number of namespaces in the list'/>
      <arg name='nsList' type='xmlNsPtr *' info='the list of in-scope namespaces to use'/>
    </function>
    <function name='xsltExtElementLookup' file='extensions'>
      <info>Looks up an extension element. @ctxt can be NULL to search only in module elements.</info>
      <return type='xsltTransformFunction' info='the element callback or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT process context'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <functype name='xsltExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *' info='a pointer to the module specific data for this transformation.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
    </functype>
    <function name='xsltExtModuleElementLookup' file='extensions'>
      <info>Looks up an extension module element</info>
      <return type='xsltTransformFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltExtModuleElementPreComputeLookup' file='extensions'>
      <info>Looks up an extension module element pre-computation function</info>
      <return type='xsltPreComputeFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltExtModuleFunctionLookup' file='extensions'>
      <info>Looks up an extension module function</info>
      <return type='xmlXPathFunction' info='the function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltExtModuleTopLevelLookup' file='extensions'>
      <info>Looks up an extension module top-level element</info>
      <return type='xsltTopLevelFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
    </function>
    <functype name='xsltExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
      <arg name='data' type='void *' info='the data associated to this module'/>
    </functype>
    <function name='xsltExtensionInstructionResultFinalize' file='xsltInternals'>
      <info>Finalizes the data (e.g. result tree fragments) created within a value-returning process (e.g. EXSLT&apos;s function). Tree fragments marked as being returned by a function are set to normal state, which means that the fragment garbage collector will free them after the function-calling process exits.</info>
      <return type='int' info='0 in case of success and -1 in case of API or internal errors.  This function is unsupported in newer releases of libxslt.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltExtensionInstructionResultRegister' file='xsltInternals'>
      <info>Marks the result of a value-returning extension instruction in order to avoid it being garbage collected before the extension instruction exits. Note that one still has to additionally register any newly created tree fragments (via xsltCreateRVT()) with xsltRegisterLocalRVT().</info>
      <return type='int' info='0 in case of success and -1 in case of error.  It isn&apos;t necessary to call this function in newer releases of libxslt.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an XPath object to be inspected for result tree fragments'/>
    </function>
    <function name='xsltFindDocument' file='documents'>
      <info>Try to find a document within the XSLT transformation context. This will not find document infos for temporary Result Tree Fragments.</info>
      <return type='xsltDocumentPtr' info='the desired xsltDocumentPtr or NULL in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltFindElemSpaceHandling' file='imports'>
      <info>Find strip-space or preserve-space information for an element respect the import precedence or the wildcards</info>
      <return type='int' info='1 if space should be stripped, 0 if not, and 2 if everything should be CDTATA wrapped.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='an XML node'/>
    </function>
    <function name='xsltFindTemplate' file='imports'>
      <info>Finds the named template, apply import precedence rule. REVISIT TODO: We&apos;ll change the nameURI fields of templates to be in the string dict, so if the specified @nameURI is in the same dict, then use pointer comparison. Check if this can be done in a sane way. Maybe this function is not needed internally at transformation-time if we hard-wire the called templates to the caller.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the template name'/>
      <arg name='nameURI' type='const xmlChar *' info='the template name URI'/>
    </function>
    <function name='xsltFlagRVTs' file='xsltInternals'>
      <info>Updates ownership information of RVTs in @obj according to @val.  @val = XSLT_RVT_FUNC_RESULT for the result of an extension function, so its RVTs won&apos;t be destroyed after leaving the returning scope. @val = XSLT_RVT_LOCAL for the result of an extension function to reset the state of its RVTs after it was returned to a new scope. @val = XSLT_RVT_GLOBAL for parts of global variables.</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an XPath object to be inspected for result tree fragments'/>
      <arg name='val' type='void *' info='the flag value'/>
    </function>
    <function name='xsltForEach' file='transform'>
      <info>Process the xslt for-each node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the &quot;current node&quot; in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the element node of the xsl:for-each instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='the compiled information of the instruction'/>
    </function>
    <function name='xsltFormatNumberConversion' file='xsltInternals'>
      <info>format-number() uses the JDK 1.1 DecimalFormat class:  http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html  Structure:  pattern    := subpattern{;subpattern} subpattern := {prefix}integer{.fraction}{suffix} prefix     := &apos;\\u0000&apos;..&apos;\\uFFFD&apos; - specialCharacters suffix     := &apos;\\u0000&apos;..&apos;\\uFFFD&apos; - specialCharacters integer    := &apos;#&apos;* &apos;0&apos;* &apos;0&apos; fraction   := &apos;0&apos;* &apos;#&apos;*  Notation: X*       0 or more instances of X (X | Y)  either X or Y. X..Y     any character from X up to Y, inclusive. S - T    characters in S, except those in T  Special Characters:  Symbol Meaning 0      a digit #      a digit, zero shows as absent .      placeholder for decimal separator ,      placeholder for grouping separator. ;      separates formats. -      default negative prefix. %      multiply by 100 and show as percentage ?      multiply by 1000 and show as per mille X      any other characters can be used in the prefix or suffix &apos;      used to quote special characters in a prefix or suffix.</info>
      <return type='xmlXPathError' info='a possible XPath error'/>
      <arg name='self' type='xsltDecimalFormatPtr' info='the decimal format'/>
      <arg name='format' type='xmlChar *' info='the format requested'/>
      <arg name='number' type='double' info='the value to format'/>
      <arg name='result' type='xmlChar **' info='the place to output the result'/>
    </function>
    <function name='xsltFormatNumberFunction' file='functions'>
      <info>Implement the format-number() XSLT function string format-number(number, string, string?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltFreeAVTList' file='xsltInternals'>
      <info>Free up the memory associated to the attribute value templates</info>
      <return type='void'/>
      <arg name='avt' type='void *' info='pointer to an list of AVT structures'/>
    </function>
    <function name='xsltFreeAttributeSetsHashes' file='attributes'>
      <info>Free up the memory used by attribute sets</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeCompMatchList' file='pattern'>
      <info>Free up the memory allocated by all the elements of @comp</info>
      <return type='void'/>
      <arg name='comp' type='xsltCompMatchPtr' info='an XSLT comp list'/>
    </function>
    <function name='xsltFreeCtxtExts' file='extensions'>
      <info>Free the XSLT extension data</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeDocumentKeys' file='keys'>
      <info>Free the keys associated to a document</info>
      <return type='void'/>
      <arg name='idoc' type='xsltDocumentPtr' info='a XSLT document'/>
    </function>
    <function name='xsltFreeDocuments' file='documents'>
      <info>Free up all the space used by the loaded documents</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeExts' file='extensions'>
      <info>Free up the memory used by XSLT extensions in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeGlobalVariables' file='variables'>
      <info>Free up the data associated to the global variables its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
    </function>
    <function name='xsltFreeKeys' file='keys'>
      <info>Free up the memory used by XSLT keys in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeLocale' file='xsltlocale'>
      <info>Frees a locale created with xsltNewLocale</info>
      <return type='void'/>
      <arg name='locale' type='xsltLocale' info='the locale to free'/>
    </function>
    <function name='xsltFreeLocales' file='xsltlocale'>
      <info>Cleanup function for the locale support on shutdown</info>
      <return type='void'/>
    </function>
    <function name='xsltFreeNamespaceAliasHashes' file='namespaces'>
      <info>Free up the memory used by namespaces aliases</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeRVTs' file='xsltInternals'>
      <info>Frees all registered result value trees (Result Tree Fragments) of the transformation. Internal function; should not be called by user-code.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeSecurityPrefs' file='security'>
      <info>Free up a security preference block</info>
      <return type='void'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to free'/>
    </function>
    <function name='xsltFreeStackElemList' file='xsltInternals'>
      <info>Free up the memory allocated by @elem</info>
      <return type='void'/>
      <arg name='elem' type='xsltStackElemPtr' info='an XSLT stack element'/>
    </function>
    <function name='xsltFreeStyleDocuments' file='documents'>
      <info>Frees the node-trees (and xsltDocument structures) of all stylesheet-modules of the stylesheet-level represented by the given @style.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet (representing a stylesheet-level)'/>
    </function>
    <function name='xsltFreeStylePreComps' file='preproc'>
      <info>Free up the memory allocated by all precomputed blocks</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeStylesheet' file='xsltInternals'>
      <info>Free up the memory allocated by @style</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeTemplateHashes' file='pattern'>
      <info>Free up the memory used by xsltAddTemplate/xsltGetTemplate mechanism</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeTransformContext' file='transform'>
      <info>Free up the memory allocated by @ctxt</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT parser context'/>
    </function>
    <function name='xsltFunctionAvailableFunction' file='functions'>
      <info>Implement the function-available() XSLT function boolean function-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltFunctionNodeSet' file='extra'>
      <info>Implement the node-set() XSLT function node-set node-set(result-tree)  This function is available in libxslt, saxon or xt namespace.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltGenerateIdFunction' file='functions'>
      <info>Implement the generate-id() XSLT function string generate-id(node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltGetCNsProp' file='xsltutils'>
      <info>Similar to xmlGetNsProp() but with a slightly different semantic  Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified, or has no namespace and the element is in that namespace.  This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='const xmlChar *' info='the attribute value or NULL if not found. The string is allocated in the stylesheet dictionary.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace'/>
    </function>
    <function name='xsltGetDebuggerStatus' file='xsltutils'>
      <info>Get xslDebugStatus.</info>
      <return type='int' info='the value of xslDebugStatus.'/>
    </function>
    <function name='xsltGetDefaultSecurityPrefs' file='security'>
      <info>Get the default security preference application-wide</info>
      <return type='xsltSecurityPrefsPtr' info='the current xsltSecurityPrefsPtr in use or NULL if none'/>
    </function>
    <function name='xsltGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given transformation.</info>
      <return type='void *' info='the pointer or NULL if not present'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module'/>
    </function>
    <function name='xsltGetExtInfo' file='extensions'>
      <info>looks up URI in extInfos of the stylesheet</info>
      <return type='xmlHashTablePtr' info='a pointer to the hash table if found, else NULL'/>
      <arg name='style' type='xsltStylesheetPtr' info='pointer to a stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI desired'/>
    </function>
    <function name='xsltGetKey' file='keys'>
      <info>Looks up a key of the in current source doc (the document info on @ctxt-&gt;document). Computes the key if not already done for the current source doc.</info>
      <return type='xmlNodeSetPtr' info='the nodeset resulting from the query or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL'/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL'/>
      <arg name='value' type='const xmlChar *' info='the key value to look for'/>
    </function>
    <function name='xsltGetNamespace' file='namespaces'>
      <info>Find a matching (prefix and ns-name) ns-declaration for the requested @ns-&gt;prefix and @ns-&gt;href in the result tree. If none is found then a new ns-declaration will be added to @resultElem. If, in this case, the given prefix is already in use, then a ns-declaration with a modified ns-prefix be we created.  Called by: - xsltCopyPropList() (*not*  anymore) - xsltShallowCopyElement() - xsltCopyTreeInternal() (*not*  anymore) - xsltApplySequenceConstructor() (*not* in the refactored code), - xsltElement() (*not* anymore)</info>
      <return type='xmlNsPtr' info='a namespace declaration or NULL in case of namespace fixup failures or API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the input node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace'/>
      <arg name='out' type='xmlNodePtr' info='the output node (or its parent)'/>
    </function>
    <function name='xsltGetNsProp' file='xsltutils'>
      <info>Similar to xmlGetNsProp() but with a slightly different semantic  Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified, or has no namespace and the element is in that namespace.  This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace'/>
    </function>
    <function name='xsltGetPlainNamespace' file='namespaces'>
      <info>Obsolete. *Not* called by any Libxslt/Libexslt function. Exaclty the same as xsltGetNamespace().</info>
      <return type='xmlNsPtr' info='a namespace declaration or NULL in case of namespace fixup failures or API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the input node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace'/>
      <arg name='out' type='xmlNodePtr' info='the result element'/>
    </function>
    <function name='xsltGetProfileInformation' file='xsltutils'>
      <info>This function should be called after the transformation completed to extract template processing profiling information if available. The information is returned as an XML document tree like &lt;?xml version=&quot;1.0&quot;?&gt; &lt;profile&gt; &lt;template rank=&quot;1&quot; match=&quot;*&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;6&quot; time=&quot;48&quot; average=&quot;8&quot;/&gt; &lt;template rank=&quot;2&quot; match=&quot;item2|item3&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;10&quot; time=&quot;30&quot; average=&quot;3&quot;/&gt; &lt;template rank=&quot;3&quot; match=&quot;item1&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;5&quot; time=&quot;17&quot; average=&quot;3&quot;/&gt; &lt;/profile&gt; The caller will need to free up the returned tree with xmlFreeDoc()</info>
      <return type='xmlDocPtr' info='the xmlDocPtr corresponding to the result or NULL if not available.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
    </function>
    <function name='xsltGetQNameURI' file='xsltutils'>
      <info>This function analyzes @name, if the name contains a prefix, the function seaches the associated namespace in scope for it. It will also replace @name value with the NCName, the old value being freed. Errors in the prefix lookup are signalled by setting @name to NULL.  NOTE: the namespace returned is a pointer to the place where it is defined and hence has the same lifespan as the document holding it.</info>
      <return type='const xmlChar *' info='the namespace URI if there is a prefix, or NULL if @name is not prefixed.'/>
      <arg name='node' type='xmlNodePtr' info='the node holding the QName'/>
      <arg name='name' type='xmlChar **' info='pointer to the initial QName value'/>
    </function>
    <function name='xsltGetQNameURI2' file='xsltutils'>
      <info>This function is similar to xsltGetQNameURI, but is used when @name is a dictionary entry.</info>
      <return type='const xmlChar *' info='the namespace URI if there is a prefix, or NULL if @name is not prefixed.'/>
      <arg name='style' type='xsltStylesheetPtr' info='stylesheet pointer'/>
      <arg name='node' type='xmlNodePtr' info='the node holding the QName'/>
      <arg name='name' type='const xmlChar **' info='pointer to the initial QName value'/>
    </function>
    <function name='xsltGetSecurityPrefs' file='security'>
      <info>Lookup the security option to get the callback checking function</info>
      <return type='xsltSecurityCheck' info='NULL if not found, the function otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to update'/>
      <arg name='option' type='xsltSecurityOption' info='the option to lookup'/>
    </function>
    <function name='xsltGetSpecialNamespace' file='namespaces'>
      <info>Find a matching (prefix and ns-name) ns-declaration for the requested @nsName and @nsPrefix in the result tree. If none is found then a new ns-declaration will be added to @resultElem. If, in this case, the given prefix is already in use, then a ns-declaration with a modified ns-prefix be we created. Note that this function&apos;s priority is to preserve ns-prefixes; it will only change a prefix if there&apos;s a namespace clash. If both @nsName and @nsPrefix are NULL, then this will try to &quot;undeclare&quot; a default namespace by declaring an xmlns=&quot;&quot;.</info>
      <return type='xmlNsPtr' info='a namespace declaration or NULL.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context'/>
      <arg name='invocNode' type='xmlNodePtr' info='the invoking node; e.g. a literal result element/attr; only used for error reports'/>
      <arg name='nsName' type='const xmlChar *' info='the namespace name (or NULL)'/>
      <arg name='nsPrefix' type='const xmlChar *' info='the suggested namespace prefix (or NULL)'/>
      <arg name='target' type='xmlNodePtr' info='the result element on which to anchor a namespace'/>
    </function>
    <function name='xsltGetTemplate' file='pattern'>
      <info>Finds the template applying to this node, if @style is non-NULL it means one needs to look for the next imported template in scope.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node being processed'/>
      <arg name='style' type='xsltStylesheetPtr' info='the current style'/>
    </function>
    <function name='xsltGetUTF8Char' file='xsltutils'>
      <info>Read one UTF8 Char from @utf Function copied from libxml2 xmlGetUTF8Char() ... to discard ultimately and use the original API</info>
      <return type='int' info='the char value or -1 in case of error and update @len with the number of bytes used'/>
      <arg name='utf' type='const unsigned char *' info='a sequence of UTF-8 encoded bytes'/>
      <arg name='len' type='int *' info='a pointer to @bytes len'/>
    </function>
    <function name='xsltGetXIncludeDefault' file='transform'>
      <info>Provides the default state for XInclude processing</info>
      <return type='int' info='0 if there is no processing 1 otherwise'/>
    </function>
    <functype name='xsltHandleDebuggerCallback' file='xsltutils'>
      <info></info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info=''/>
      <arg name='node' type='xmlNodePtr' info=''/>
      <arg name='templ' type='xsltTemplatePtr' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
    </functype>
    <function name='xsltIf' file='transform'>
      <info>Processes the xsl:if instruction on the source node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the current node in the source tree'/>
      <arg name='inst' type='xmlNodePtr' info='the xsl:if instruction'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='compiled information of the instruction'/>
    </function>
    <function name='xsltInit' file='xslt'>
      <info>Initializes the processor (e.g. registers built-in extensions, etc.)</info>
      <return type='void'/>
    </function>
    <function name='xsltInitAllDocKeys' file='xsltInternals'>
      <info>INTERNAL ROUTINE ONLY  Check if any keys on the current document need to be computed</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='transformation context'/>
    </function>
    <function name='xsltInitCtxtExts' file='extensions'>
      <info>Initialize the set of modules with registered stylesheet data</info>
      <return type='int' info='the number of modules initialized or -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltInitCtxtKey' file='xsltInternals'>
      <info>Computes the key tables this key and for the current input document.</info>
      <return type='int' info='0 on success, -1 on error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='idoc' type='xsltDocumentPtr' info='the document information (holds key values)'/>
      <arg name='keyDef' type='xsltKeyDefPtr' info='the key definition'/>
    </function>
    <function name='xsltInitCtxtKeys' file='keys'>
      <info>Computes all the keys tables for the current input document. Should be done before global varibales are initialized. NOTE: Not used anymore in the refactored code.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='idoc' type='xsltDocumentPtr' info='a document info'/>
    </function>
    <function name='xsltInitElemPreComp' file='extensions'>
      <info>Initializes an existing #xsltElemPreComp structure. This is usefull when extending an #xsltElemPreComp to store precomputed data. This function MUST be called on any extension element precomputed data struct.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='an #xsltElemPreComp (or generally a derived structure)'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
      <arg name='function' type='xsltTransformFunction' info='the transform function'/>
      <arg name='freeFunc' type='xsltElemPreCompDeallocator' info='the @comp deallocator'/>
    </function>
    <function name='xsltInitGlobals' file='extensions'>
      <info>Initialize the global variables for extensions</info>
      <return type='void'/>
    </function>
    <function name='xsltIsBlank' file='xsltInternals'>
      <info>Check if a string is ignorable</info>
      <return type='int' info='1 if the string is NULL or made of blanks chars, 0 otherwise'/>
      <arg name='str' type='xmlChar *' info='a string'/>
    </function>
    <function name='xsltKeyFunction' file='functions'>
      <info>Implement the key() XSLT function node-set key(string, object)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltLoadDocument' file='documents'>
      <info>Try to load a document (not a stylesheet) within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document'/>
    </function>
    <function name='xsltLoadStyleDocument' file='documents'>
      <info>Try to load a stylesheet document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet'/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document'/>
    </function>
    <function name='xsltLoadStylesheetPI' file='xsltInternals'>
      <info>This function tries to locate the stylesheet PI in the given document If found, and if contained within the document, it will extract that subtree to build the stylesheet to process @doc (doc itself will be modified). If found but referencing an external document it will attempt to load it and generate a stylesheet from it. In both cases, the resulting stylesheet and the document need to be freed once the transformation is done.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure or NULL if not found.'/>
      <arg name='doc' type='xmlDocPtr' info='a document to process'/>
    </function>
    <function name='xsltLocalVariablePop' file='transform'>
      <info>Pops all variable values at the given @depth from the stack.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context'/>
      <arg name='limitNr' type='int' info='number of variables which should remain'/>
      <arg name='level' type='int' info='the depth in the xsl:template&apos;s tree'/>
    </function>
    <function name='xsltLocalVariablePush' file='transform'>
      <info>Places the variable onto the local variable stack</info>
      <return type='int' info='0 for success, -1 for any error **NOTE:** This is an internal routine and should not be called by users!'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context'/>
      <arg name='variable' type='xsltStackElemPtr' info='variable to be pushed to the variable stack'/>
      <arg name='level' type='int' info='new value for variable&apos;s level'/>
    </function>
    <function name='xsltLocaleStrcmp' file='xsltlocale'>
      <info>Compares two strings transformed with xsltStrxfrm</info>
      <return type='int' info='a value &lt; 0 if str1 sorts before str2, a value &gt; 0 if str1 sorts after str2, 0 if str1 and str2 are equal wrt sorting'/>
      <arg name='locale' type='xsltLocale' info='a locale identifier'/>
      <arg name='str1' type='const xsltLocaleChar *' info='a string transformed with xsltStrxfrm'/>
      <arg name='str2' type='const xsltLocaleChar *' info='a string transformed with xsltStrxfrm'/>
    </function>
    <function name='xsltMatchPattern' file='pattern'>
      <info></info>
      <return type='int' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
      <arg name='node' type='xmlNodePtr' info=''/>
      <arg name='pattern' type='const xmlChar *' info=''/>
      <arg name='ctxtdoc' type='xmlDocPtr' info=''/>
      <arg name='ctxtnode' type='xmlNodePtr' info=''/>
    </function>
    <function name='xsltMessage' file='xsltutils'>
      <info>Process and xsl:message construct</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='The node containing the message instruction'/>
    </function>
    <function name='xsltNamespaceAlias' file='namespaces'>
      <info>Read the stylesheet-prefix and result-prefix attributes, register them as well as the corresponding namespace.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the xsl:namespace-alias node'/>
    </function>
    <function name='xsltNeedElemSpaceHandling' file='imports'>
      <info>Checks whether that stylesheet requires white-space stripping</info>
      <return type='int' info='1 if space should be stripped, 0 if not'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltNewDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr' info='a handler to the document'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context (or NULL)'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltNewElemPreComp' file='extensions'>
      <info>Creates and initializes an #xsltElemPreComp</info>
      <return type='xsltElemPreCompPtr' info='the new and initialized #xsltElemPreComp'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
      <arg name='function' type='xsltTransformFunction' info='the transform function'/>
    </function>
    <function name='xsltNewLocale' file='xsltlocale'>
      <info>Creates a new locale of an opaque system dependent type based on the language tag.</info>
      <return type='xsltLocale' info='the locale or NULL on error or if no matching locale was found'/>
      <arg name='languageTag' type='const xmlChar *' info='RFC 3066 language tag'/>
    </function>
    <function name='xsltNewSecurityPrefs' file='security'>
      <info>Create a new security preference block</info>
      <return type='xsltSecurityPrefsPtr' info='a pointer to the new block or NULL in case of error'/>
    </function>
    <function name='xsltNewStyleDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr' info='a handler to the document'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltNewStylesheet' file='xsltInternals'>
      <info>Create a new XSLT Stylesheet</info>
      <return type='xsltStylesheetPtr' info='the newly allocated xsltStylesheetPtr or NULL in case of error'/>
    </function>
    <function name='xsltNewTransformContext' file='transform'>
      <info>Create a new XSLT TransformContext</info>
      <return type='xsltTransformContextPtr' info='the newly allocated xsltTransformContextPtr or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='the input document'/>
    </function>
    <function name='xsltNextImport' file='imports'>
      <info>Find the next stylesheet in import precedence.</info>
      <return type='xsltStylesheetPtr' info='the next stylesheet or NULL if it was the last one'/>
      <arg name='cur' type='xsltStylesheetPtr' info='the current XSLT stylesheet'/>
    </function>
    <function name='xsltNormalizeCompSteps' file='pattern'>
      <info>This is a hashtable scanner function to normalize the compiled steps of an imported stylesheet.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='pointer to template hash table entry'/>
      <arg name='data' type='void *' info='pointer to the stylesheet'/>
      <arg name='name' type='const xmlChar *' info='template match name'/>
    </function>
    <function name='xsltNumber' file='transform'>
      <info>Process the xslt number node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt number node'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltNumberFormat' file='xsltInternals'>
      <info>Convert one number.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='data' type='xsltNumberDataPtr' info='the formatting information'/>
      <arg name='node' type='xmlNodePtr' info='the data to format'/>
    </function>
    <function name='xsltParseAnyXSLTElem' file='xsltInternals'>
      <info>Parses, validates the content models and compiles XSLT instructions.</info>
      <return type='int' info='0 if everything&apos;s fine; -1 on API or internal errors.'/>
      <arg name='cctxt' type='xsltCompilerCtxtPtr' info='the compilation context'/>
      <arg name='elem' type='xmlNodePtr' info='the element node of the XSLT instruction'/>
    </function>
    <function name='xsltParseGlobalParam' file='variables'>
      <info>parse an XSLT transformation param declaration and record its value.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element'/>
    </function>
    <function name='xsltParseGlobalVariable' file='variables'>
      <info>Parses a global XSLT &apos;variable&apos; declaration at compilation time and registers it</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;variable&quot; element'/>
    </function>
    <function name='xsltParseSequenceConstructor' file='xsltInternals'>
      <info>Parses a &quot;template&quot; content (or &quot;sequence constructor&quot; in XSLT 2.0 terms). This will additionally remove xsl:text elements from the tree.</info>
      <return type='void'/>
      <arg name='cctxt' type='xsltCompilerCtxtPtr' info='the compilation context'/>
      <arg name='cur' type='xmlNodePtr' info='the start-node of the content to be parsed'/>
    </function>
    <function name='xsltParseStylesheetAttributeSet' file='attributes'>
      <info>parse an XSLT stylesheet attribute-set element</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;attribute-set&quot; element'/>
    </function>
    <function name='xsltParseStylesheetCallerParam' file='variables'>
      <info>Processes an xsl:with-param instruction at transformation time. The value is computed, but not recorded. NOTE that this is also called with an *xsl:param* element from exsltFuncFunctionFunction().</info>
      <return type='xsltStackElemPtr' info='the new xsltStackElemPtr or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='inst' type='xmlNodePtr' info='the xsl:with-param instruction element'/>
    </function>
    <function name='xsltParseStylesheetDoc' file='xsltInternals'>
      <info>parse an XSLT stylesheet, building the associated structures.  doc is kept as a reference within the returned stylesheet, so changes to doc after the parsing will be reflected when the stylesheet is applied, and the doc is automatically freed when the stylesheet is closed.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetFile' file='xsltInternals'>
      <info>Load and parse an XSLT stylesheet</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='filename' type='const xmlChar *' info='the filename/URL to the stylesheet'/>
    </function>
    <function name='xsltParseStylesheetImport' file='imports'>
      <info>parse an XSLT stylesheet import element</info>
      <return type='int' info='0 in case of success -1 in case of failure.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the import element'/>
    </function>
    <function name='xsltParseStylesheetImportedDoc' file='xsltInternals'>
      <info>parse an XSLT stylesheet building the associated structures except the processing not needed for imported documents.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='doc' type='xmlDocPtr' info='an xmlDoc parsed XML'/>
      <arg name='parentStyle' type='xsltStylesheetPtr' info='pointer to the parent stylesheet (if it exists)'/>
    </function>
    <function name='xsltParseStylesheetInclude' file='imports'>
      <info>parse an XSLT stylesheet include element</info>
      <return type='int' info='0 in case of success -1 in case of failure'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the include node'/>
    </function>
    <function name='xsltParseStylesheetOutput' file='xsltInternals'>
      <info>parse an XSLT stylesheet output element and record information related to the stylesheet output</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;output&quot; element'/>
    </function>
    <function name='xsltParseStylesheetParam' file='variables'>
      <info>Registers a local XSLT &apos;param&apos; declaration at transformation time and evaluates its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the XSLT &apos;param&apos; element'/>
    </function>
    <function name='xsltParseStylesheetProcess' file='xsltInternals'>
      <info>Parses an XSLT stylesheet, adding the associated structures. Called by: xsltParseStylesheetImportedDoc() (xslt.c) xsltParseStylesheetInclude() (imports.c)</info>
      <return type='xsltStylesheetPtr' info='the value of the @style parameter if everything went right, NULL if something went amiss.'/>
      <arg name='ret' type='xsltStylesheetPtr' info='the XSLT stylesheet (the current stylesheet-level)'/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetUser' file='xsltInternals'>
      <info>Parse an XSLT stylesheet with a user-provided stylesheet struct.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='style' type='xsltStylesheetPtr' info='pointer to the stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='an xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetVariable' file='variables'>
      <info>Registers a local XSLT &apos;variable&apos; instruction at transformation time and evaluates its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='inst' type='xmlNodePtr' info='the xsl:variable instruction element'/>
    </function>
    <function name='xsltParseTemplateContent' file='xsltInternals'>
      <info>parse a template content-model Clean-up the template content from unwanted ignorable blank nodes and process xslt:text</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='templ' type='xmlNodePtr' info='the container node (can be a document for literal results)'/>
    </function>
    <function name='xsltPointerListAddSize' file='xsltInternals'>
      <info>Adds an item to the list.</info>
      <return type='int' info='the position of the added item in the list or -1 in case of an error.'/>
      <arg name='list' type='xsltPointerListPtr' info='the pointer list structure'/>
      <arg name='item' type='void *' info='the item to be stored'/>
      <arg name='initialSize' type='int' info='the initial size of the list'/>
    </function>
    <function name='xsltPointerListClear' file='xsltInternals'>
      <info>Resets the list, but does not free the allocated array and does not free the content of the list.</info>
      <return type='void'/>
      <arg name='list' type='xsltPointerListPtr' info='pointer to the list to be cleared'/>
    </function>
    <function name='xsltPointerListCreate' file='xsltInternals'>
      <info>Creates an xsltPointerList structure.</info>
      <return type='xsltPointerListPtr' info='a xsltPointerList structure or NULL in case of an error.'/>
      <arg name='initialSize' type='int' info='the initial size for the list'/>
    </function>
    <function name='xsltPointerListFree' file='xsltInternals'>
      <info>Frees the xsltPointerList structure. This does not free the content of the list.</info>
      <return type='void'/>
      <arg name='list' type='xsltPointerListPtr' info='pointer to the list to be freed'/>
    </function>
    <function name='xsltPreComputeExtModuleElement' file='extensions'>
      <info>Precomputes an extension module element</info>
      <return type='xsltElemPreCompPtr' info='the precomputed data'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
    </function>
    <functype name='xsltPreComputeFunction' file='extensions'>
      <info></info>
      <return type='xsltElemPreCompPtr' info=''/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='inst' type='xmlNodePtr' info=''/>
      <arg name='function' type='xsltTransformFunction' info=''/>
    </functype>
    <function name='xsltPrintErrorContext' file='xsltutils'>
      <info>Display the context of an error.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the current node being processed'/>
    </function>
    <function name='xsltProcessOneNode' file='transform'>
      <info>Process the source node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='contextNode' type='xmlNodePtr' info='the &quot;current node&quot; in the source tree'/>
      <arg name='withParams' type='xsltStackElemPtr' info='extra parameters (e.g. xsl:with-param) passed to the template if any'/>
    </function>
    <function name='xsltProcessingInstruction' file='transform'>
      <info>Process the xslt processing-instruction node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt processing-instruction node'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltProfileStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and dump the profiling to the given output.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
      <arg name='output' type='FILE *' info='a FILE * for the profiling output'/>
    </function>
    <function name='xsltQuoteOneUserParam' file='variables'>
      <info>This is normally called from xsltQuoteUserParams to process a single parameter from a list of parameters.  The @value is stored in the context&apos;s global variable/parameter hash table.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='a null terminated string giving the name of the parameter'/>
      <arg name='value' type='const xmlChar *' info='a null terminated string giving the parameter value'/>
    </function>
    <function name='xsltQuoteUserParams' file='variables'>
      <info>Similar to xsltEvalUserParams, but the values are treated literally and are * *not* evaluated as XPath expressions. This should be done on parsed stylesheets before starting to apply transformations.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
    </function>
    <function name='xsltRegisterAllElement' file='transform'>
      <info>Registers all default XSLT elements in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XPath context'/>
    </function>
    <function name='xsltRegisterAllExtras' file='extra'>
      <info>Registers the built-in extensions</info>
      <return type='void'/>
    </function>
    <function name='xsltRegisterAllFunctions' file='functions'>
      <info>Registers all default XSLT functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xsltRegisterExtElement' file='extensions'>
      <info>Registers an extension element</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the name of the element'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element'/>
      <arg name='function' type='xsltTransformFunction' info='the actual implementation which should be called'/>
    </function>
    <function name='xsltRegisterExtFunction' file='extensions'>
      <info>Registers an extension function</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the name of the element'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element'/>
      <arg name='function' type='xmlXPathFunction' info='the actual implementation which should be called'/>
    </function>
    <function name='xsltRegisterExtModule' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function'/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function'/>
    </function>
    <function name='xsltRegisterExtModuleElement' file='extensions'>
      <info>Registers an extension module element.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
      <arg name='precomp' type='xsltPreComputeFunction' info='the pre-computation callback'/>
      <arg name='transform' type='xsltTransformFunction' info='the transformation callback'/>
    </function>
    <function name='xsltRegisterExtModuleFull' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function'/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function'/>
      <arg name='styleInitFunc' type='xsltStyleExtInitFunction' info='the module initialization function'/>
      <arg name='styleShutdownFunc' type='xsltStyleExtShutdownFunction' info='the module shutdown function'/>
    </function>
    <function name='xsltRegisterExtModuleFunction' file='extensions'>
      <info>Registers an extension module function.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
      <arg name='function' type='xmlXPathFunction' info='the function callback'/>
    </function>
    <function name='xsltRegisterExtModuleTopLevel' file='extensions'>
      <info>Registers an extension module top-level element.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
      <arg name='function' type='xsltTopLevelFunction' info='the top-level element callback'/>
    </function>
    <function name='xsltRegisterExtPrefix' file='extensions'>
      <info>Registers an extension namespace This is called from xslt.c during compile-time. The given prefix is not needed. Called by: xsltParseExtElemPrefixes() (new function) xsltRegisterExtPrefix() (old function)</info>
      <return type='int' info='0 in case of success, 1 if the @URI was already registered as an extension namespace and -1 in case of failure'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix used (optional)'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the extension'/>
    </function>
    <function name='xsltRegisterExtras' file='extra'>
      <info>Registers the built-in extensions. This function is deprecated, use xsltRegisterAllExtras instead.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
    </function>
    <function name='xsltRegisterLocalRVT' file='xsltInternals'>
      <info>Registers a result value tree (XSLT 1.0 term: Result Tree Fragment) in the RVT garbage collector. The fragment will be freed when the instruction which created the fragment exits.</info>
      <return type='int' info='0 in case of success and -1 in case of API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree (Result Tree Fragment; xmlDocPtr)'/>
    </function>
    <function name='xsltRegisterPersistRVT' file='xsltInternals'>
      <info>Register the result value tree (XSLT 1.0 term: Result Tree Fragment) in the fragment garbage collector. The fragment will be freed when the transformation context is freed.</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree (Result Tree Fragment)'/>
    </function>
    <function name='xsltRegisterTestModule' file='extensions'>
      <info>Registers the test module</info>
      <return type='void'/>
    </function>
    <function name='xsltRegisterTmpRVT' file='xsltInternals'>
      <info>Registers the result value tree (XSLT 1.0 term: Result Tree Fragment) in the garbage collector. The fragment will be freed at the exit of the currently instantiated xsl:template. Obsolete; this function might produce massive memory overhead, since the fragment is only freed when the current xsl:template exits. Use xsltRegisterLocalRVT() instead.</info>
      <return type='int' info='0 in case of success and -1 in case of API or internal errors.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree (Result Tree Fragment)'/>
    </function>
    <function name='xsltReleaseRVT' file='xsltInternals'>
      <info>Either frees the RVT (which is an xmlDoc) or stores it in the context&apos;s cache for later reuse.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree (Result Tree Fragment)'/>
    </function>
    <function name='xsltResolveStylesheetAttributeSet' file='attributes'>
      <info>resolve the references between attribute sets.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
    </function>
    <function name='xsltRestoreDocumentNamespaces' file='xsltInternals'>
      <info>Restore the namespaces for the document</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ns' type='xsltNsMapPtr' info='map of namespaces'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xsltRunStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and generate the output according to @output @SAX and @IObuf. It&apos;s an error to specify both @SAX and @IObuf.  NOTE: This may lead to a non-wellformed output XML wise ! NOTE: This may also result in multiple files being generated NOTE: using IObuf, the result encoding used will be the one used for creating the output buffer, use the following macro to read it from the stylesheet XSLT_GET_IMPORT_PTR(encoding, style, encoding) NOTE: using SAX, any encoding specified in the stylesheet will be lost since the interface uses only UTF8</info>
      <return type='int' info='the number of bytes written to the main resource or -1 in case of error.'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated array of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the URL/filename ot the generated resource if available'/>
      <arg name='SAX' type='xmlSAXHandlerPtr' info='a SAX handler for progressive callback output (not implemented yet)'/>
      <arg name='IObuf' type='xmlOutputBufferPtr' info='an output buffer for progressive output (not implemented yet)'/>
    </function>
    <function name='xsltRunStylesheetUser' file='transform'>
      <info>Apply the stylesheet to the document and generate the output according to @output @SAX and @IObuf. It&apos;s an error to specify both @SAX and @IObuf.  NOTE: This may lead to a non-wellformed output XML wise ! NOTE: This may also result in multiple files being generated NOTE: using IObuf, the result encoding used will be the one used for creating the output buffer, use the following macro to read it from the stylesheet XSLT_GET_IMPORT_PTR(encoding, style, encoding) NOTE: using SAX, any encoding specified in the stylesheet will be lost since the interface uses only UTF8</info>
      <return type='int' info='the number of by written to the main resource or -1 in case of error.'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated array of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the URL/filename ot the generated resource if available'/>
      <arg name='SAX' type='xmlSAXHandlerPtr' info='a SAX handler for progressive callback output (not implemented yet)'/>
      <arg name='IObuf' type='xmlOutputBufferPtr' info='an output buffer for progressive output (not implemented yet)'/>
      <arg name='profile' type='FILE *' info='profile FILE * output or NULL'/>
      <arg name='userCtxt' type='xsltTransformContextPtr' info='user provided transform context'/>
    </function>
    <function name='xsltSaveProfiling' file='xsltutils'>
      <info>Save the profiling information on @output</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT context'/>
      <arg name='output' type='FILE *' info='a FILE * for saving the information'/>
    </function>
    <function name='xsltSaveResultTo' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an I/O output channel @buf</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output buffer'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFd' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an open file descriptor This does not close the descriptor.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='fd' type='int' info='a file descriptor'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFile' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an open FILE * I/O. This does not close the FILE @file</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='file' type='FILE *' info='a FILE * I/O'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFilename' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to a file or @URL</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='URL' type='const char *' info='a filename or URL'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='compression' type='int' info='the compression factor (0 - 9 included)'/>
    </function>
    <function name='xsltSaveResultToString' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to a new allocated string.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text'/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSecurityAllow' file='security'>
      <info>Function used to always allow an operation</info>
      <return type='int' info='1 always'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='value' type='const char *' info='unused'/>
    </function>
    <functype name='xsltSecurityCheck' file='security'>
      <info>User provided function to check the value of a string like a file path or an URL ...</info>
      <return type='int' info=''/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
      <arg name='value' type='const char *' info=''/>
    </functype>
    <function name='xsltSecurityForbid' file='security'>
      <info>Function used to always forbid an operation</info>
      <return type='int' info='0 always'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='value' type='const char *' info='unused'/>
    </function>
    <function name='xsltSetCtxtParseOptions' file='xsltutils'>
      <info>Change the default parser option passed by the XSLT engine to the parser when using document() loading.</info>
      <return type='int' info='the previous options or -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='options' type='int' info='a combination of libxml2 xmlParserOption'/>
    </function>
    <function name='xsltSetCtxtSecurityPrefs' file='security'>
      <info>Set the security preference for a specific transformation</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltSetCtxtSortFunc' file='xsltutils'>
      <info>Function to set the handler for XSLT sorting for the specified context. If the handler is NULL, then the global sort function will be called</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='handler' type='xsltSortFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetDebuggerCallbacks' file='xsltutils'>
      <info>This function allow to plug a debugger into the XSLT library @block points to a block of memory containing the address of @no callback routines.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='no' type='int' info='number of callbacks'/>
      <arg name='block' type='void *' info='the block of callbacks'/>
    </function>
    <function name='xsltSetDebuggerStatus' file='xsltutils'>
      <info>This function sets the value of xslDebugStatus.</info>
      <return type='void'/>
      <arg name='value' type='int' info='the value to be set'/>
    </function>
    <function name='xsltSetDefaultSecurityPrefs' file='security'>
      <info>Set the default security preference application-wide</info>
      <return type='void'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
    </function>
    <function name='xsltSetGenericDebugFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing or validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE * than stderr by setting @ctx to this file handle and @handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetGenericErrorFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE * than stderr by setting @ctx to this file handle and @handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetLoaderFunc' file='documents'>
      <info>Set the new function to load document, if NULL it resets it to the default function.</info>
      <return type='void'/>
      <arg name='f' type='xsltDocLoaderFunc' info='the new function to handle document loading.'/>
    </function>
    <function name='xsltSetSecurityPrefs' file='security'>
      <info>Update the security option to use the new callback checking function</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to update'/>
      <arg name='option' type='xsltSecurityOption' info='the option to update'/>
      <arg name='func' type='xsltSecurityCheck' info='the user callback to use for this option'/>
    </function>
    <function name='xsltSetSortFunc' file='xsltutils'>
      <info>Function to reset the global handler for XSLT sorting. If the handler is NULL, the default sort function will be used.</info>
      <return type='void'/>
      <arg name='handler' type='xsltSortFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetTransformErrorFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages specific to a given XSLT transromation.  This simply means that @handler will be called for subsequent error messages while running the transformation.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetXIncludeDefault' file='transform'>
      <info>Set whether XInclude should be processed on document being loaded by default</info>
      <return type='void'/>
      <arg name='xinclude' type='int' info='whether to do XInclude processing'/>
    </function>
    <function name='xsltShutdownCtxtExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltShutdownExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltSort' file='transform'>
      <info>function attached to xsl:sort nodes, but this should not be called directly</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt sort node'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <functype name='xsltSortFunc' file='xsltInternals'>
      <info>Signature of the function to use during sorting</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='sorts' type='xmlNodePtr *' info='the node-set to sort'/>
      <arg name='nbsorts' type='int' info='the number of sorts'/>
    </functype>
    <function name='xsltSplitQName' file='xsltutils'>
      <info>Split QNames into prefix and local names, both allocated from a dictionary.</info>
      <return type='const xmlChar *' info='the localname or NULL in case of error.'/>
      <arg name='dict' type='xmlDictPtr' info='a dictionary'/>
      <arg name='name' type='const xmlChar *' info='the full QName'/>
      <arg name='prefix' type='const xmlChar **' info='the return value'/>
    </function>
    <function name='xsltStrxfrm' file='xsltlocale'>
      <info>Transforms a string according to locale. The transformed string must then be compared with xsltLocaleStrcmp and freed with xmlFree.</info>
      <return type='xsltLocaleChar *' info='the transformed string or NULL on error'/>
      <arg name='locale' type='xsltLocale' info='locale created with xsltNewLocale'/>
      <arg name='string' type='const xmlChar *' info='UTF-8 string to transform'/>
    </function>
    <functype name='xsltStyleExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *' info='a pointer to the module specific data for this transformation.'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
    </functype>
    <functype name='xsltStyleExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
      <arg name='data' type='void *' info='the data associated to this module'/>
    </functype>
    <function name='xsltStyleGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given stylesheet. Called by: xsltRegisterExtPrefix(), ( xsltExtElementPreCompTest(), xsltExtInitTest )</info>
      <return type='void *' info='the pointer or NULL if not present'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module'/>
    </function>
    <function name='xsltStylePreCompute' file='preproc'>
      <info>Precompute an XSLT stylesheet element</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
    </function>
    <function name='xsltStyleStylesheetLevelGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given stylesheet.</info>
      <return type='void *' info='the pointer or NULL if not present'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module'/>
    </function>
    <function name='xsltSystemPropertyFunction' file='functions'>
      <info>Implement the system-property() XSLT function object system-property(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltTemplateProcess' file='templates'>
      <info>Obsolete. Don&apos;t use it.</info>
      <return type='xmlNodePtr *' info='NULL.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the attribute template node'/>
    </function>
    <function name='xsltTestCompMatchList' file='pattern'>
      <info>Test whether the node matches one of the patterns in the list</info>
      <return type='int' info='1 if it matches, 0 if it doesn&apos;t and -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='comp' type='xsltCompMatchPtr' info='the precompiled pattern list'/>
    </function>
    <function name='xsltText' file='transform'>
      <info>Process the xslt text node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt text node'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltTimestamp' file='xsltutils'>
      <info>Used for gathering profiling data</info>
      <return type='long' info='the number of tenth of milliseconds since the beginning of the profiling'/>
    </function>
    <functype name='xsltTopLevelFunction' file='extensions'>
      <info></info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='inst' type='xmlNodePtr' info=''/>
    </functype>
    <function name='xsltTransformError' file='xsltutils'>
      <info>Display and format an error messages, gives file, line, position and extra parameters, will use the specific transformation context if available</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet used'/>
      <arg name='node' type='xmlNodePtr' info='the current node in the stylesheet'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <functype name='xsltTransformFunction' file='xsltInternals'>
      <info>Signature of the function associated to elements part of the stylesheet language like xsl:if or xsl:apply-templates.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the input node'/>
      <arg name='inst' type='xmlNodePtr' info='the stylesheet node'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the compiled information from the stylesheet'/>
    </functype>
    <function name='xsltUninit' file='xsltInternals'>
      <info>Uninitializes the processor.</info>
      <return type='void'/>
    </function>
    <function name='xsltUnparsedEntityURIFunction' file='functions'>
      <info>Implement the unparsed-entity-uri() XSLT function string unparsed-entity-uri(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltUnregisterExtModule' file='extensions'>
      <info>Unregister an XSLT extension module from the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
    </function>
    <function name='xsltUnregisterExtModuleElement' file='extensions'>
      <info>Unregisters an extension module element</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltUnregisterExtModuleFunction' file='extensions'>
      <info>Unregisters an extension module function</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltUnregisterExtModuleTopLevel' file='extensions'>
      <info>Unregisters an extension module top-level element</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
    </function>
    <function name='xsltValueOf' file='transform'>
      <info>Process the xslt value-of node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt value-of node'/>
      <arg name='castedComp' type='xsltElemPreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltVariableLookup' file='variables'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
    </function>
    <function name='xsltXPathCompile' file='xsltutils'>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr' info='the xmlXPathCompExprPtr resulting from the compilation or NULL. the caller has to free the object.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
    </function>
    <function name='xsltXPathCompileFlags' file='xsltutils'>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr' info='the xmlXPathCompExprPtr resulting from the compilation or NULL. the caller has to free the object.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
      <arg name='flags' type='int' info='extra compilation flags to pass down to libxml2 XPath'/>
    </function>
    <function name='xsltXPathFunctionLookup' file='functions'>
      <info>This is the entry point when a function is needed by the XPath interpretor.</info>
      <return type='xmlXPathFunction' info='the callback function or NULL if not found'/>
      <arg name='vctxt' type='void *' info='a void * but the XSLT transformation context actually'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltXPathGetTransformContext' file='extensions'>
      <info>Provides the XSLT transformation context from the XPath transformation context. This is useful when an XPath function in the extension module is called by the XPath interpreter and that the XSLT context is needed for example to retrieve the associated data pertaining to this XSLT transformation.</info>
      <return type='xsltTransformContextPtr' info='the XSLT transformation context or NULL in case of error.'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath transformation context'/>
    </function>
    <function name='xsltXPathVariableLookup' file='variables'>
      <info>This is the entry point when a varibale is needed by the XPath interpretor.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found'/>
      <arg name='ctxt' type='void *' info='a void * but the the XSLT transformation context actually'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
    </function>
  </symbols>
</api>
